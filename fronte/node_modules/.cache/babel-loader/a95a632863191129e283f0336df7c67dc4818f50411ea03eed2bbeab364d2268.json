{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  getClassNameFromSelector: () => getClassNameFromSelector,\n  resolveMatches: () => resolveMatches,\n  generateRules: () => generateRules\n});\nconst _postcss = /*#__PURE__*/_interopRequireDefault(require(\"postcss\"));\nconst _postcssSelectorParser = /*#__PURE__*/_interopRequireDefault(require(\"postcss-selector-parser\"));\nconst _parseObjectStyles = /*#__PURE__*/_interopRequireDefault(require(\"../util/parseObjectStyles\"));\nconst _isPlainObject = /*#__PURE__*/_interopRequireDefault(require(\"../util/isPlainObject\"));\nconst _prefixSelector = /*#__PURE__*/_interopRequireDefault(require(\"../util/prefixSelector\"));\nconst _pluginUtils = require(\"../util/pluginUtils\");\nconst _log = /*#__PURE__*/_interopRequireDefault(require(\"../util/log\"));\nconst _sharedState = /*#__PURE__*/_interopRequireWildcard(require(\"./sharedState\"));\nconst _formatVariantSelector = require(\"../util/formatVariantSelector\");\nconst _nameClass = require(\"../util/nameClass\");\nconst _dataTypes = require(\"../util/dataTypes\");\nconst _setupContextUtils = require(\"./setupContextUtils\");\nconst _isValidArbitraryValue = /*#__PURE__*/_interopRequireDefault(require(\"../util/isValidArbitraryValue\"));\nconst _splitAtTopLevelOnlyJs = require(\"../util/splitAtTopLevelOnly.js\");\nconst _featureFlags = require(\"../featureFlags\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nlet classNameParser = (0, _postcssSelectorParser.default)(selectors => {\n  return selectors.first.filter(_ref => {\n    let {\n      type\n    } = _ref;\n    return type === \"class\";\n  }).pop().value;\n});\nfunction getClassNameFromSelector(selector) {\n  return classNameParser.transformSync(selector);\n}\n// Generate match permutations for a class candidate, like:\n// ['ring-offset-blue', '100']\n// ['ring-offset', 'blue-100']\n// ['ring', 'offset-blue-100']\n// Example with dynamic classes:\n// ['grid-cols', '[[linename],1fr,auto]']\n// ['grid', 'cols-[[linename],1fr,auto]']\nfunction* candidatePermutations(candidate) {\n  let lastIndex = Infinity;\n  while (lastIndex >= 0) {\n    let dashIdx;\n    let wasSlash = false;\n    if (lastIndex === Infinity && candidate.endsWith(\"]\")) {\n      let bracketIdx = candidate.indexOf(\"[\");\n      // If character before `[` isn't a dash or a slash, this isn't a dynamic class\n      // eg. string[]\n      if (candidate[bracketIdx - 1] === \"-\") {\n        dashIdx = bracketIdx - 1;\n      } else if (candidate[bracketIdx - 1] === \"/\") {\n        dashIdx = bracketIdx - 1;\n        wasSlash = true;\n      } else {\n        dashIdx = -1;\n      }\n    } else if (lastIndex === Infinity && candidate.includes(\"/\")) {\n      dashIdx = candidate.lastIndexOf(\"/\");\n      wasSlash = true;\n    } else {\n      dashIdx = candidate.lastIndexOf(\"-\", lastIndex);\n    }\n    if (dashIdx < 0) {\n      break;\n    }\n    let prefix = candidate.slice(0, dashIdx);\n    let modifier = candidate.slice(wasSlash ? dashIdx : dashIdx + 1);\n    lastIndex = dashIdx - 1;\n    // TODO: This feels a bit hacky\n    if (prefix === \"\" || modifier === \"/\") {\n      continue;\n    }\n    yield [prefix, modifier];\n  }\n}\nfunction applyPrefix(matches, context) {\n  if (matches.length === 0 || context.tailwindConfig.prefix === \"\") {\n    return matches;\n  }\n  for (let match of matches) {\n    let [meta] = match;\n    if (meta.options.respectPrefix) {\n      let container = _postcss.default.root({\n        nodes: [match[1].clone()]\n      });\n      let classCandidate = match[1].raws.tailwind.classCandidate;\n      container.walkRules(r => {\n        // If this is a negative utility with a dash *before* the prefix we\n        // have to ensure that the generated selector matches the candidate\n        // Not doing this will cause `-tw-top-1` to generate the class `.tw--top-1`\n        // The disconnect between candidate <-> class can cause @apply to hard crash.\n        let shouldPrependNegative = classCandidate.startsWith(\"-\");\n        r.selector = (0, _prefixSelector.default)(context.tailwindConfig.prefix, r.selector, shouldPrependNegative);\n      });\n      match[1] = container.nodes[0];\n    }\n  }\n  return matches;\n}\nfunction applyImportant(matches, classCandidate) {\n  if (matches.length === 0) {\n    return matches;\n  }\n  let result = [];\n  for (let [meta, rule] of matches) {\n    let container = _postcss.default.root({\n      nodes: [rule.clone()]\n    });\n    container.walkRules(r => {\n      r.selector = (0, _pluginUtils.updateAllClasses)((0, _pluginUtils.filterSelectorsForClass)(r.selector, classCandidate), className => {\n        if (className === classCandidate) {\n          return `!${className}`;\n        }\n        return className;\n      });\n      r.walkDecls(d => d.important = true);\n    });\n    result.push([{\n      ...meta,\n      important: true\n    }, container.nodes[0]]);\n  }\n  return result;\n}\n// Takes a list of rule tuples and applies a variant like `hover`, sm`,\n// whatever to it. We used to do some extra caching here to avoid generating\n// a variant of the same rule more than once, but this was never hit because\n// we cache at the entire selector level further up the tree.\n//\n// Technically you can get a cache hit if you have `hover:focus:text-center`\n// and `focus:hover:text-center` in the same project, but it doesn't feel\n// worth the complexity for that case.\nfunction applyVariant(variant, matches, context) {\n  if (matches.length === 0) {\n    return matches;\n  }\n  /** @type {{modifier: string | null, value: string | null}} */\n  let args = {\n    modifier: null,\n    value: _sharedState.NONE\n  };\n  // Retrieve \"modifier\"\n  {\n    let match = /(.*)\\/(.*)$/g.exec(variant);\n    if (match) {\n      variant = match[1];\n      args.modifier = match[2];\n      if (!(0, _featureFlags.flagEnabled)(context.tailwindConfig, \"generalizedModifiers\")) {\n        return [];\n      }\n    }\n  }\n  // Retrieve \"arbitrary value\"\n  if (variant.endsWith(\"]\") && !variant.startsWith(\"[\")) {\n    // We either have:\n    //   @[200px]\n    //   group-[:hover]\n    //\n    // But we don't want:\n    //   @-[200px]        (`-` is incorrect)\n    //   group[:hover]    (`-` is missing)\n    let match1 = /(.)(-?)\\[(.*)\\]/g.exec(variant);\n    if (match1) {\n      let [, char, seperator, value] = match1;\n      // @-[200px] case\n      if (char === \"@\" && seperator === \"-\") return [];\n      // group[:hover] case\n      if (char !== \"@\" && seperator === \"\") return [];\n      variant = variant.replace(`${seperator}[${value}]`, \"\");\n      args.value = value;\n    }\n  }\n  // Register arbitrary variants\n  if (isArbitraryValue(variant) && !context.variantMap.has(variant)) {\n    let selector = (0, _dataTypes.normalize)(variant.slice(1, -1));\n    if (!(0, _setupContextUtils.isValidVariantFormatString)(selector)) {\n      return [];\n    }\n    let fn = (0, _setupContextUtils.parseVariant)(selector);\n    let sort = context.offsets.recordVariant(variant);\n    context.variantMap.set(variant, [[sort, fn]]);\n  }\n  if (context.variantMap.has(variant)) {\n    let variantFunctionTuples = context.variantMap.get(variant).slice();\n    let result = [];\n    for (let [meta, rule] of matches) {\n      // Don't generate variants for user css\n      if (meta.layer === \"user\") {\n        continue;\n      }\n      let container = _postcss.default.root({\n        nodes: [rule.clone()]\n      });\n      for (let [variantSort, variantFunction, containerFromArray] of variantFunctionTuples) {\n        let clone = (containerFromArray !== null && containerFromArray !== void 0 ? containerFromArray : container).clone();\n        let collectedFormats = [];\n        function prepareBackup() {\n          // Already prepared, chicken out\n          if (clone.raws.neededBackup) {\n            return;\n          }\n          clone.raws.neededBackup = true;\n          clone.walkRules(rule => rule.raws.originalSelector = rule.selector);\n        }\n        function modifySelectors(modifierFunction) {\n          prepareBackup();\n          clone.each(rule => {\n            if (rule.type !== \"rule\") {\n              return;\n            }\n            rule.selectors = rule.selectors.map(selector => {\n              return modifierFunction({\n                get className() {\n                  return getClassNameFromSelector(selector);\n                },\n                selector\n              });\n            });\n          });\n          return clone;\n        }\n        let ruleWithVariant = variantFunction({\n          // Public API\n          get container() {\n            prepareBackup();\n            return clone;\n          },\n          separator: context.tailwindConfig.separator,\n          modifySelectors,\n          // Private API for now\n          wrap(wrapper) {\n            let nodes = clone.nodes;\n            clone.removeAll();\n            wrapper.append(nodes);\n            clone.append(wrapper);\n          },\n          format(selectorFormat) {\n            collectedFormats.push(selectorFormat);\n          },\n          args\n        });\n        // It can happen that a list of format strings is returned from within the function. In that\n        // case, we have to process them as well. We can use the existing `variantSort`.\n        if (Array.isArray(ruleWithVariant)) {\n          for (let [idx, variantFunction1] of ruleWithVariant.entries()) {\n            // This is a little bit scary since we are pushing to an array of items that we are\n            // currently looping over. However, you can also think of it like a processing queue\n            // where you keep handling jobs until everything is done and each job can queue more\n            // jobs if needed.\n            variantFunctionTuples.push([context.offsets.applyParallelOffset(variantSort, idx), variantFunction1,\n            // If the clone has been modified we have to pass that back\n            // though so each rule can use the modified container\n            clone.clone()]);\n          }\n          continue;\n        }\n        if (typeof ruleWithVariant === \"string\") {\n          collectedFormats.push(ruleWithVariant);\n        }\n        if (ruleWithVariant === null) {\n          continue;\n        }\n        // We had to backup selectors, therefore we assume that somebody touched\n        // `container` or `modifySelectors`. Let's see if they did, so that we\n        // can restore the selectors, and collect the format strings.\n        if (clone.raws.neededBackup) {\n          delete clone.raws.neededBackup;\n          clone.walkRules(rule => {\n            let before = rule.raws.originalSelector;\n            if (!before) return;\n            delete rule.raws.originalSelector;\n            if (before === rule.selector) return; // No mutation happened\n            let modified = rule.selector;\n            // Rebuild the base selector, this is what plugin authors would do\n            // as well. E.g.: `${variant}${separator}${className}`.\n            // However, plugin authors probably also prepend or append certain\n            // classes, pseudos, ids, ...\n            let rebuiltBase = (0, _postcssSelectorParser.default)(selectors => {\n              selectors.walkClasses(classNode => {\n                classNode.value = `${variant}${context.tailwindConfig.separator}${classNode.value}`;\n              });\n            }).processSync(before);\n            // Now that we know the original selector, the new selector, and\n            // the rebuild part in between, we can replace the part that plugin\n            // authors need to rebuild with `&`, and eventually store it in the\n            // collectedFormats. Similar to what `format('...')` would do.\n            //\n            // E.g.:\n            //                   variant: foo\n            //                  selector: .markdown > p\n            //      modified (by plugin): .foo .foo\\\\:markdown > p\n            //    rebuiltBase (internal): .foo\\\\:markdown > p\n            //                    format: .foo &\n            collectedFormats.push(modified.replace(rebuiltBase, \"&\"));\n            rule.selector = before;\n          });\n        }\n        // This tracks the originating layer for the variant\n        // For example:\n        // .sm:underline {} is a variant of something in the utilities layer\n        // .sm:container {} is a variant of the container component\n        clone.nodes[0].raws.tailwind = {\n          ...clone.nodes[0].raws.tailwind,\n          parentLayer: meta.layer\n        };\n        var _collectedFormats;\n        let withOffset = [{\n          ...meta,\n          sort: context.offsets.applyVariantOffset(meta.sort, variantSort, Object.assign(args, context.variantOptions.get(variant))),\n          collectedFormats: ((_collectedFormats = meta.collectedFormats) !== null && _collectedFormats !== void 0 ? _collectedFormats : []).concat(collectedFormats),\n          isArbitraryVariant: isArbitraryValue(variant)\n        }, clone.nodes[0]];\n        result.push(withOffset);\n      }\n    }\n    return result;\n  }\n  return [];\n}\nfunction parseRules(rule, cache) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // PostCSS node\n  if (!(0, _isPlainObject.default)(rule) && !Array.isArray(rule)) {\n    return [[rule], options];\n  }\n  // Tuple\n  if (Array.isArray(rule)) {\n    return parseRules(rule[0], cache, rule[1]);\n  }\n  // Simple object\n  if (!cache.has(rule)) {\n    cache.set(rule, (0, _parseObjectStyles.default)(rule));\n  }\n  return [cache.get(rule), options];\n}\nconst IS_VALID_PROPERTY_NAME = /^[a-z_-]/;\nfunction isValidPropName(name) {\n  return IS_VALID_PROPERTY_NAME.test(name);\n}\n/**\n * @param {string} declaration\n * @returns {boolean}\n */\nfunction looksLikeUri(declaration) {\n  // Quick bailout for obvious non-urls\n  // This doesn't support schemes that don't use a leading // but that's unlikely to be a problem\n  if (!declaration.includes(\"://\")) {\n    return false;\n  }\n  try {\n    const url = new URL(declaration);\n    return url.scheme !== \"\" && url.host !== \"\";\n  } catch (err) {\n    // Definitely not a valid url\n    return false;\n  }\n}\nfunction isParsableNode(node) {\n  let isParsable = true;\n  node.walkDecls(decl => {\n    if (!isParsableCssValue(decl.name, decl.value)) {\n      isParsable = false;\n      return false;\n    }\n  });\n  return isParsable;\n}\nfunction isParsableCssValue(property, value) {\n  // We don't want to to treat [https://example.com] as a custom property\n  // Even though, according to the CSS grammar, it's a totally valid CSS declaration\n  // So we short-circuit here by checking if the custom property looks like a url\n  if (looksLikeUri(`${property}:${value}`)) {\n    return false;\n  }\n  try {\n    _postcss.default.parse(`a{${property}:${value}}`).toResult();\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\nfunction extractArbitraryProperty(classCandidate, context) {\n  var ref;\n  let [, property, value] = (ref = classCandidate.match(/^\\[([a-zA-Z0-9-_]+):(\\S+)\\]$/)) !== null && ref !== void 0 ? ref : [];\n  if (value === undefined) {\n    return null;\n  }\n  if (!isValidPropName(property)) {\n    return null;\n  }\n  if (!(0, _isValidArbitraryValue.default)(value)) {\n    return null;\n  }\n  let normalized = (0, _dataTypes.normalize)(value);\n  if (!isParsableCssValue(property, normalized)) {\n    return null;\n  }\n  let sort = context.offsets.arbitraryProperty();\n  return [[{\n    sort,\n    layer: \"utilities\"\n  }, () => ({\n    [(0, _nameClass.asClass)(classCandidate)]: {\n      [property]: normalized\n    }\n  })]];\n}\nfunction* resolveMatchedPlugins(classCandidate, context) {\n  if (context.candidateRuleMap.has(classCandidate)) {\n    yield [context.candidateRuleMap.get(classCandidate), \"DEFAULT\"];\n  }\n  yield* function* (arbitraryPropertyRule) {\n    if (arbitraryPropertyRule !== null) {\n      yield [arbitraryPropertyRule, \"DEFAULT\"];\n    }\n  }(extractArbitraryProperty(classCandidate, context));\n  let candidatePrefix = classCandidate;\n  let negative = false;\n  const twConfigPrefix = context.tailwindConfig.prefix;\n  const twConfigPrefixLen = twConfigPrefix.length;\n  const hasMatchingPrefix = candidatePrefix.startsWith(twConfigPrefix) || candidatePrefix.startsWith(`-${twConfigPrefix}`);\n  if (candidatePrefix[twConfigPrefixLen] === \"-\" && hasMatchingPrefix) {\n    negative = true;\n    candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1);\n  }\n  if (negative && context.candidateRuleMap.has(candidatePrefix)) {\n    yield [context.candidateRuleMap.get(candidatePrefix), \"-DEFAULT\"];\n  }\n  for (let [prefix, modifier] of candidatePermutations(candidatePrefix)) {\n    if (context.candidateRuleMap.has(prefix)) {\n      yield [context.candidateRuleMap.get(prefix), negative ? `-${modifier}` : modifier];\n    }\n  }\n}\nfunction splitWithSeparator(input, separator) {\n  if (input === _sharedState.NOT_ON_DEMAND) {\n    return [_sharedState.NOT_ON_DEMAND];\n  }\n  return (0, _splitAtTopLevelOnlyJs.splitAtTopLevelOnly)(input, separator);\n}\nfunction* recordCandidates(matches, classCandidate) {\n  for (const match of matches) {\n    var ref;\n    var ref1;\n    match[1].raws.tailwind = {\n      ...match[1].raws.tailwind,\n      classCandidate,\n      preserveSource: (ref1 = (ref = match[0].options) === null || ref === void 0 ? void 0 : ref.preserveSource) !== null && ref1 !== void 0 ? ref1 : false\n    };\n    yield match;\n  }\n}\nfunction resolveMatches(candidate, context) {\n  let original = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : candidate;\n  return function* () {\n    let separator = context.tailwindConfig.separator;\n    let [classCandidate, ...variants] = splitWithSeparator(candidate, separator).reverse();\n    let important = false;\n    if (classCandidate.startsWith(\"!\")) {\n      important = true;\n      classCandidate = classCandidate.slice(1);\n    }\n    if ((0, _featureFlags.flagEnabled)(context.tailwindConfig, \"variantGrouping\")) {\n      if (classCandidate.startsWith(\"(\") && classCandidate.endsWith(\")\")) {\n        let base = variants.slice().reverse().join(separator);\n        for (let part of (0, _splitAtTopLevelOnlyJs.splitAtTopLevelOnly)(classCandidate.slice(1, -1), \",\")) {\n          yield* resolveMatches(base + separator + part, context, original);\n        }\n      }\n    }\n    // TODO: Reintroduce this in ways that doesn't break on false positives\n    // function sortAgainst(toSort, against) {\n    //   return toSort.slice().sort((a, z) => {\n    //     return bigSign(against.get(a)[0] - against.get(z)[0])\n    //   })\n    // }\n    // let sorted = sortAgainst(variants, context.variantMap)\n    // if (sorted.toString() !== variants.toString()) {\n    //   let corrected = sorted.reverse().concat(classCandidate).join(':')\n    //   throw new Error(`Class ${candidate} should be written as ${corrected}`)\n    // }\n    for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context)) {\n      let matches = [];\n      let typesByMatches = new Map();\n      let [plugins, modifier] = matchedPlugins;\n      let isOnlyPlugin = plugins.length === 1;\n      for (let [sort, plugin] of plugins) {\n        let matchesPerPlugin = [];\n        if (typeof plugin === \"function\") {\n          for (let ruleSet of [].concat(plugin(modifier, {\n            isOnlyPlugin\n          }))) {\n            let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);\n            for (let rule of rules) {\n              matchesPerPlugin.push([{\n                ...sort,\n                options: {\n                  ...sort.options,\n                  ...options\n                }\n              }, rule]);\n            }\n          }\n        } else if (modifier === \"DEFAULT\" || modifier === \"-DEFAULT\") {\n          let ruleSet1 = plugin;\n          let [rules1, options1] = parseRules(ruleSet1, context.postCssNodeCache);\n          for (let rule1 of rules1) {\n            matchesPerPlugin.push([{\n              ...sort,\n              options: {\n                ...sort.options,\n                ...options1\n              }\n            }, rule1]);\n          }\n        }\n        if (matchesPerPlugin.length > 0) {\n          var ref;\n          var ref1, _options;\n          let matchingTypes = Array.from((0, _pluginUtils.getMatchingTypes)((ref1 = (ref = sort.options) === null || ref === void 0 ? void 0 : ref.types) !== null && ref1 !== void 0 ? ref1 : [], modifier, (_options = sort.options) !== null && _options !== void 0 ? _options : {}, context.tailwindConfig)).map(_ref2 => {\n            let [_, type] = _ref2;\n            return type;\n          });\n          if (matchingTypes.length > 0) {\n            typesByMatches.set(matchesPerPlugin, matchingTypes);\n          }\n          matches.push(matchesPerPlugin);\n        }\n      }\n      if (isArbitraryValue(modifier)) {\n        if (matches.length > 1) {\n          // Partition plugins in 2 categories so that we can start searching in the plugins that\n          // don't have `any` as a type first.\n          let [withAny, withoutAny] = matches.reduce((group, plugin) => {\n            let hasAnyType = plugin.some(_ref3 => {\n              let [{\n                options\n              }] = _ref3;\n              return options.types.some(_ref4 => {\n                let {\n                  type\n                } = _ref4;\n                return type === \"any\";\n              });\n            });\n            if (hasAnyType) {\n              group[0].push(plugin);\n            } else {\n              group[1].push(plugin);\n            }\n            return group;\n          }, [[], []]);\n          function findFallback(matches) {\n            // If only a single plugin matches, let's take that one\n            if (matches.length === 1) {\n              return matches[0];\n            }\n            // Otherwise, find the plugin that creates a valid rule given the arbitrary value, and\n            // also has the correct type which preferOnConflicts the plugin in case of clashes.\n            return matches.find(rules => {\n              let matchingTypes = typesByMatches.get(rules);\n              return rules.some(_ref5 => {\n                let [{\n                  options\n                }, rule] = _ref5;\n                if (!isParsableNode(rule)) {\n                  return false;\n                }\n                return options.types.some(_ref6 => {\n                  let {\n                    type,\n                    preferOnConflict\n                  } = _ref6;\n                  return matchingTypes.includes(type) && preferOnConflict;\n                });\n              });\n            });\n          }\n          var ref2;\n          // Try to find a fallback plugin, because we already know that multiple plugins matched for\n          // the given arbitrary value.\n          let fallback = (ref2 = findFallback(withoutAny)) !== null && ref2 !== void 0 ? ref2 : findFallback(withAny);\n          if (fallback) {\n            matches = [fallback];\n          } else {\n            var ref3;\n            let typesPerPlugin = matches.map(match => new Set([...((ref3 = typesByMatches.get(match)) !== null && ref3 !== void 0 ? ref3 : [])]));\n            // Remove duplicates, so that we can detect proper unique types for each plugin.\n            for (let pluginTypes of typesPerPlugin) {\n              for (let type of pluginTypes) {\n                let removeFromOwnGroup = false;\n                for (let otherGroup of typesPerPlugin) {\n                  if (pluginTypes === otherGroup) continue;\n                  if (otherGroup.has(type)) {\n                    otherGroup.delete(type);\n                    removeFromOwnGroup = true;\n                  }\n                }\n                if (removeFromOwnGroup) pluginTypes.delete(type);\n              }\n            }\n            let messages = [];\n            for (let [idx, group] of typesPerPlugin.entries()) {\n              for (let type1 of group) {\n                let rules2 = matches[idx].map(_ref7 => {\n                  let [, rule] = _ref7;\n                  return rule;\n                }).flat().map(rule => rule.toString().split(\"\\n\").slice(1, -1) // Remove selector and closing '}'\n                .map(line => line.trim()).map(x => `      ${x}`) // Re-indent\n                .join(\"\\n\")).join(\"\\n\\n\");\n                messages.push(`  Use \\`${candidate.replace(\"[\", `[${type1}:`)}\\` for \\`${rules2.trim()}\\``);\n                break;\n              }\n            }\n            _log.default.warn([`The class \\`${candidate}\\` is ambiguous and matches multiple utilities.`, ...messages, `If this is content and not a class, replace it with \\`${candidate.replace(\"[\", \"&lsqb;\").replace(\"]\", \"&rsqb;\")}\\` to silence this warning.`]);\n            continue;\n          }\n        }\n        matches = matches.map(list => list.filter(match => isParsableNode(match[1])));\n      }\n      matches = matches.flat();\n      matches = Array.from(recordCandidates(matches, classCandidate));\n      matches = applyPrefix(matches, context);\n      if (important) {\n        matches = applyImportant(matches, classCandidate);\n      }\n      for (let variant of variants) {\n        matches = applyVariant(variant, matches, context);\n      }\n      for (let match of matches) {\n        match[1].raws.tailwind = {\n          ...match[1].raws.tailwind,\n          candidate\n        };\n        // Apply final format selector\n        if (match[0].collectedFormats) {\n          let finalFormat = (0, _formatVariantSelector.formatVariantSelector)(\"&\", ...match[0].collectedFormats);\n          let container = _postcss.default.root({\n            nodes: [match[1].clone()]\n          });\n          container.walkRules(rule => {\n            var ref;\n            if (inKeyframes(rule)) return;\n            var ref1;\n            rule.selector = (0, _formatVariantSelector.finalizeSelector)(finalFormat, {\n              selector: rule.selector,\n              candidate: original,\n              base: candidate.split(new RegExp(`\\\\${(ref1 = context === null || context === void 0 ? void 0 : (ref = context.tailwindConfig) === null || ref === void 0 ? void 0 : ref.separator) !== null && ref1 !== void 0 ? ref1 : \":\"}(?![^[]*\\\\])`)).pop(),\n              isArbitraryVariant: match[0].isArbitraryVariant,\n              context\n            });\n          });\n          match[1] = container.nodes[0];\n        }\n        yield match;\n      }\n    }\n  }();\n}\nfunction inKeyframes(rule) {\n  return rule.parent && rule.parent.type === \"atrule\" && rule.parent.name === \"keyframes\";\n}\nfunction getImportantStrategy(important) {\n  if (important === true) {\n    return rule => {\n      if (inKeyframes(rule)) {\n        return;\n      }\n      rule.walkDecls(d => {\n        if (d.parent.type === \"rule\" && !inKeyframes(d.parent)) {\n          d.important = true;\n        }\n      });\n    };\n  }\n  if (typeof important === \"string\") {\n    return rule => {\n      if (inKeyframes(rule)) {\n        return;\n      }\n      rule.selectors = rule.selectors.map(selector => {\n        return `${important} ${selector}`;\n      });\n    };\n  }\n}\nfunction generateRules(candidates, context) {\n  let allRules = [];\n  let strategy = getImportantStrategy(context.tailwindConfig.important);\n  for (let candidate of candidates) {\n    if (context.notClassCache.has(candidate)) {\n      continue;\n    }\n    if (context.candidateRuleCache.has(candidate)) {\n      allRules = allRules.concat(Array.from(context.candidateRuleCache.get(candidate)));\n      continue;\n    }\n    let matches = Array.from(resolveMatches(candidate, context));\n    if (matches.length === 0) {\n      context.notClassCache.add(candidate);\n      continue;\n    }\n    context.classCache.set(candidate, matches);\n    var ref;\n    let rules = (ref = context.candidateRuleCache.get(candidate)) !== null && ref !== void 0 ? ref : new Set();\n    context.candidateRuleCache.set(candidate, rules);\n    for (const match of matches) {\n      let [{\n        sort,\n        options\n      }, rule] = match;\n      if (options.respectImportant && strategy) {\n        let container = _postcss.default.root({\n          nodes: [rule.clone()]\n        });\n        container.walkRules(strategy);\n        rule = container.nodes[0];\n      }\n      let newEntry = [sort, rule];\n      rules.add(newEntry);\n      context.ruleCache.add(newEntry);\n      allRules.push(newEntry);\n    }\n  }\n  return allRules;\n}\nfunction isArbitraryValue(input) {\n  return input.startsWith(\"[\") && input.endsWith(\"]\");\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_export","target","all","name","enumerable","get","getClassNameFromSelector","resolveMatches","generateRules","_postcss","_interopRequireDefault","require","_postcssSelectorParser","_parseObjectStyles","_isPlainObject","_prefixSelector","_pluginUtils","_log","_sharedState","_interopRequireWildcard","_formatVariantSelector","_nameClass","_dataTypes","_setupContextUtils","_isValidArbitraryValue","_splitAtTopLevelOnlyJs","_featureFlags","obj","__esModule","default","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","classNameParser","selectors","first","filter","type","pop","selector","transformSync","candidatePermutations","candidate","lastIndex","Infinity","dashIdx","wasSlash","endsWith","bracketIdx","indexOf","includes","lastIndexOf","prefix","slice","modifier","applyPrefix","matches","context","length","tailwindConfig","match","meta","options","respectPrefix","container","root","nodes","clone","classCandidate","raws","tailwind","walkRules","r","shouldPrependNegative","startsWith","applyImportant","result","rule","updateAllClasses","filterSelectorsForClass","className","walkDecls","d","important","push","applyVariant","variant","args","NONE","exec","flagEnabled","match1","char","seperator","replace","isArbitraryValue","variantMap","normalize","isValidVariantFormatString","fn","parseVariant","sort","offsets","recordVariant","variantFunctionTuples","layer","variantSort","variantFunction","containerFromArray","collectedFormats","prepareBackup","neededBackup","originalSelector","modifySelectors","modifierFunction","each","map","ruleWithVariant","separator","wrap","wrapper","removeAll","append","format","selectorFormat","Array","isArray","idx","variantFunction1","entries","applyParallelOffset","before","modified","rebuiltBase","walkClasses","classNode","processSync","parentLayer","_collectedFormats","withOffset","applyVariantOffset","assign","variantOptions","concat","isArbitraryVariant","parseRules","IS_VALID_PROPERTY_NAME","isValidPropName","test","looksLikeUri","declaration","url","URL","scheme","host","err","isParsableNode","node","isParsable","decl","isParsableCssValue","property","parse","toResult","extractArbitraryProperty","ref","undefined","normalized","arbitraryProperty","asClass","resolveMatchedPlugins","candidateRuleMap","arbitraryPropertyRule","candidatePrefix","negative","twConfigPrefix","twConfigPrefixLen","hasMatchingPrefix","splitWithSeparator","input","NOT_ON_DEMAND","splitAtTopLevelOnly","recordCandidates","ref1","preserveSource","original","variants","reverse","base","join","part","matchedPlugins","typesByMatches","Map","plugins","isOnlyPlugin","plugin","matchesPerPlugin","ruleSet","rules","postCssNodeCache","ruleSet1","rules1","options1","rule1","_options","matchingTypes","from","getMatchingTypes","types","_","withAny","withoutAny","reduce","group","hasAnyType","some","findFallback","find","preferOnConflict","ref2","fallback","ref3","typesPerPlugin","Set","pluginTypes","removeFromOwnGroup","otherGroup","delete","messages","type1","rules2","flat","toString","split","line","trim","x","warn","list","finalFormat","formatVariantSelector","inKeyframes","finalizeSelector","RegExp","parent","getImportantStrategy","candidates","allRules","strategy","notClassCache","candidateRuleCache","add","classCache","respectImportant","newEntry","ruleCache"],"sources":["/home/sahithya/bios/login/fronte/node_modules/tailwindcss/lib/lib/generateRules.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getClassNameFromSelector: ()=>getClassNameFromSelector,\n    resolveMatches: ()=>resolveMatches,\n    generateRules: ()=>generateRules\n});\nconst _postcss = /*#__PURE__*/ _interopRequireDefault(require(\"postcss\"));\nconst _postcssSelectorParser = /*#__PURE__*/ _interopRequireDefault(require(\"postcss-selector-parser\"));\nconst _parseObjectStyles = /*#__PURE__*/ _interopRequireDefault(require(\"../util/parseObjectStyles\"));\nconst _isPlainObject = /*#__PURE__*/ _interopRequireDefault(require(\"../util/isPlainObject\"));\nconst _prefixSelector = /*#__PURE__*/ _interopRequireDefault(require(\"../util/prefixSelector\"));\nconst _pluginUtils = require(\"../util/pluginUtils\");\nconst _log = /*#__PURE__*/ _interopRequireDefault(require(\"../util/log\"));\nconst _sharedState = /*#__PURE__*/ _interopRequireWildcard(require(\"./sharedState\"));\nconst _formatVariantSelector = require(\"../util/formatVariantSelector\");\nconst _nameClass = require(\"../util/nameClass\");\nconst _dataTypes = require(\"../util/dataTypes\");\nconst _setupContextUtils = require(\"./setupContextUtils\");\nconst _isValidArbitraryValue = /*#__PURE__*/ _interopRequireDefault(require(\"../util/isValidArbitraryValue\"));\nconst _splitAtTopLevelOnlyJs = require(\"../util/splitAtTopLevelOnly.js\");\nconst _featureFlags = require(\"../featureFlags\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nlet classNameParser = (0, _postcssSelectorParser.default)((selectors)=>{\n    return selectors.first.filter(({ type  })=>type === \"class\").pop().value;\n});\nfunction getClassNameFromSelector(selector) {\n    return classNameParser.transformSync(selector);\n}\n// Generate match permutations for a class candidate, like:\n// ['ring-offset-blue', '100']\n// ['ring-offset', 'blue-100']\n// ['ring', 'offset-blue-100']\n// Example with dynamic classes:\n// ['grid-cols', '[[linename],1fr,auto]']\n// ['grid', 'cols-[[linename],1fr,auto]']\nfunction* candidatePermutations(candidate) {\n    let lastIndex = Infinity;\n    while(lastIndex >= 0){\n        let dashIdx;\n        let wasSlash = false;\n        if (lastIndex === Infinity && candidate.endsWith(\"]\")) {\n            let bracketIdx = candidate.indexOf(\"[\");\n            // If character before `[` isn't a dash or a slash, this isn't a dynamic class\n            // eg. string[]\n            if (candidate[bracketIdx - 1] === \"-\") {\n                dashIdx = bracketIdx - 1;\n            } else if (candidate[bracketIdx - 1] === \"/\") {\n                dashIdx = bracketIdx - 1;\n                wasSlash = true;\n            } else {\n                dashIdx = -1;\n            }\n        } else if (lastIndex === Infinity && candidate.includes(\"/\")) {\n            dashIdx = candidate.lastIndexOf(\"/\");\n            wasSlash = true;\n        } else {\n            dashIdx = candidate.lastIndexOf(\"-\", lastIndex);\n        }\n        if (dashIdx < 0) {\n            break;\n        }\n        let prefix = candidate.slice(0, dashIdx);\n        let modifier = candidate.slice(wasSlash ? dashIdx : dashIdx + 1);\n        lastIndex = dashIdx - 1;\n        // TODO: This feels a bit hacky\n        if (prefix === \"\" || modifier === \"/\") {\n            continue;\n        }\n        yield [\n            prefix,\n            modifier\n        ];\n    }\n}\nfunction applyPrefix(matches, context) {\n    if (matches.length === 0 || context.tailwindConfig.prefix === \"\") {\n        return matches;\n    }\n    for (let match of matches){\n        let [meta] = match;\n        if (meta.options.respectPrefix) {\n            let container = _postcss.default.root({\n                nodes: [\n                    match[1].clone()\n                ]\n            });\n            let classCandidate = match[1].raws.tailwind.classCandidate;\n            container.walkRules((r)=>{\n                // If this is a negative utility with a dash *before* the prefix we\n                // have to ensure that the generated selector matches the candidate\n                // Not doing this will cause `-tw-top-1` to generate the class `.tw--top-1`\n                // The disconnect between candidate <-> class can cause @apply to hard crash.\n                let shouldPrependNegative = classCandidate.startsWith(\"-\");\n                r.selector = (0, _prefixSelector.default)(context.tailwindConfig.prefix, r.selector, shouldPrependNegative);\n            });\n            match[1] = container.nodes[0];\n        }\n    }\n    return matches;\n}\nfunction applyImportant(matches, classCandidate) {\n    if (matches.length === 0) {\n        return matches;\n    }\n    let result = [];\n    for (let [meta, rule] of matches){\n        let container = _postcss.default.root({\n            nodes: [\n                rule.clone()\n            ]\n        });\n        container.walkRules((r)=>{\n            r.selector = (0, _pluginUtils.updateAllClasses)((0, _pluginUtils.filterSelectorsForClass)(r.selector, classCandidate), (className)=>{\n                if (className === classCandidate) {\n                    return `!${className}`;\n                }\n                return className;\n            });\n            r.walkDecls((d)=>d.important = true);\n        });\n        result.push([\n            {\n                ...meta,\n                important: true\n            },\n            container.nodes[0]\n        ]);\n    }\n    return result;\n}\n// Takes a list of rule tuples and applies a variant like `hover`, sm`,\n// whatever to it. We used to do some extra caching here to avoid generating\n// a variant of the same rule more than once, but this was never hit because\n// we cache at the entire selector level further up the tree.\n//\n// Technically you can get a cache hit if you have `hover:focus:text-center`\n// and `focus:hover:text-center` in the same project, but it doesn't feel\n// worth the complexity for that case.\nfunction applyVariant(variant, matches, context) {\n    if (matches.length === 0) {\n        return matches;\n    }\n    /** @type {{modifier: string | null, value: string | null}} */ let args = {\n        modifier: null,\n        value: _sharedState.NONE\n    };\n    // Retrieve \"modifier\"\n    {\n        let match = /(.*)\\/(.*)$/g.exec(variant);\n        if (match) {\n            variant = match[1];\n            args.modifier = match[2];\n            if (!(0, _featureFlags.flagEnabled)(context.tailwindConfig, \"generalizedModifiers\")) {\n                return [];\n            }\n        }\n    }\n    // Retrieve \"arbitrary value\"\n    if (variant.endsWith(\"]\") && !variant.startsWith(\"[\")) {\n        // We either have:\n        //   @[200px]\n        //   group-[:hover]\n        //\n        // But we don't want:\n        //   @-[200px]        (`-` is incorrect)\n        //   group[:hover]    (`-` is missing)\n        let match1 = /(.)(-?)\\[(.*)\\]/g.exec(variant);\n        if (match1) {\n            let [, char, seperator, value] = match1;\n            // @-[200px] case\n            if (char === \"@\" && seperator === \"-\") return [];\n            // group[:hover] case\n            if (char !== \"@\" && seperator === \"\") return [];\n            variant = variant.replace(`${seperator}[${value}]`, \"\");\n            args.value = value;\n        }\n    }\n    // Register arbitrary variants\n    if (isArbitraryValue(variant) && !context.variantMap.has(variant)) {\n        let selector = (0, _dataTypes.normalize)(variant.slice(1, -1));\n        if (!(0, _setupContextUtils.isValidVariantFormatString)(selector)) {\n            return [];\n        }\n        let fn = (0, _setupContextUtils.parseVariant)(selector);\n        let sort = context.offsets.recordVariant(variant);\n        context.variantMap.set(variant, [\n            [\n                sort,\n                fn\n            ]\n        ]);\n    }\n    if (context.variantMap.has(variant)) {\n        let variantFunctionTuples = context.variantMap.get(variant).slice();\n        let result = [];\n        for (let [meta, rule] of matches){\n            // Don't generate variants for user css\n            if (meta.layer === \"user\") {\n                continue;\n            }\n            let container = _postcss.default.root({\n                nodes: [\n                    rule.clone()\n                ]\n            });\n            for (let [variantSort, variantFunction, containerFromArray] of variantFunctionTuples){\n                let clone = (containerFromArray !== null && containerFromArray !== void 0 ? containerFromArray : container).clone();\n                let collectedFormats = [];\n                function prepareBackup() {\n                    // Already prepared, chicken out\n                    if (clone.raws.neededBackup) {\n                        return;\n                    }\n                    clone.raws.neededBackup = true;\n                    clone.walkRules((rule)=>rule.raws.originalSelector = rule.selector);\n                }\n                function modifySelectors(modifierFunction) {\n                    prepareBackup();\n                    clone.each((rule)=>{\n                        if (rule.type !== \"rule\") {\n                            return;\n                        }\n                        rule.selectors = rule.selectors.map((selector)=>{\n                            return modifierFunction({\n                                get className () {\n                                    return getClassNameFromSelector(selector);\n                                },\n                                selector\n                            });\n                        });\n                    });\n                    return clone;\n                }\n                let ruleWithVariant = variantFunction({\n                    // Public API\n                    get container () {\n                        prepareBackup();\n                        return clone;\n                    },\n                    separator: context.tailwindConfig.separator,\n                    modifySelectors,\n                    // Private API for now\n                    wrap (wrapper) {\n                        let nodes = clone.nodes;\n                        clone.removeAll();\n                        wrapper.append(nodes);\n                        clone.append(wrapper);\n                    },\n                    format (selectorFormat) {\n                        collectedFormats.push(selectorFormat);\n                    },\n                    args\n                });\n                // It can happen that a list of format strings is returned from within the function. In that\n                // case, we have to process them as well. We can use the existing `variantSort`.\n                if (Array.isArray(ruleWithVariant)) {\n                    for (let [idx, variantFunction1] of ruleWithVariant.entries()){\n                        // This is a little bit scary since we are pushing to an array of items that we are\n                        // currently looping over. However, you can also think of it like a processing queue\n                        // where you keep handling jobs until everything is done and each job can queue more\n                        // jobs if needed.\n                        variantFunctionTuples.push([\n                            context.offsets.applyParallelOffset(variantSort, idx),\n                            variantFunction1,\n                            // If the clone has been modified we have to pass that back\n                            // though so each rule can use the modified container\n                            clone.clone()\n                        ]);\n                    }\n                    continue;\n                }\n                if (typeof ruleWithVariant === \"string\") {\n                    collectedFormats.push(ruleWithVariant);\n                }\n                if (ruleWithVariant === null) {\n                    continue;\n                }\n                // We had to backup selectors, therefore we assume that somebody touched\n                // `container` or `modifySelectors`. Let's see if they did, so that we\n                // can restore the selectors, and collect the format strings.\n                if (clone.raws.neededBackup) {\n                    delete clone.raws.neededBackup;\n                    clone.walkRules((rule)=>{\n                        let before = rule.raws.originalSelector;\n                        if (!before) return;\n                        delete rule.raws.originalSelector;\n                        if (before === rule.selector) return; // No mutation happened\n                        let modified = rule.selector;\n                        // Rebuild the base selector, this is what plugin authors would do\n                        // as well. E.g.: `${variant}${separator}${className}`.\n                        // However, plugin authors probably also prepend or append certain\n                        // classes, pseudos, ids, ...\n                        let rebuiltBase = (0, _postcssSelectorParser.default)((selectors)=>{\n                            selectors.walkClasses((classNode)=>{\n                                classNode.value = `${variant}${context.tailwindConfig.separator}${classNode.value}`;\n                            });\n                        }).processSync(before);\n                        // Now that we know the original selector, the new selector, and\n                        // the rebuild part in between, we can replace the part that plugin\n                        // authors need to rebuild with `&`, and eventually store it in the\n                        // collectedFormats. Similar to what `format('...')` would do.\n                        //\n                        // E.g.:\n                        //                   variant: foo\n                        //                  selector: .markdown > p\n                        //      modified (by plugin): .foo .foo\\\\:markdown > p\n                        //    rebuiltBase (internal): .foo\\\\:markdown > p\n                        //                    format: .foo &\n                        collectedFormats.push(modified.replace(rebuiltBase, \"&\"));\n                        rule.selector = before;\n                    });\n                }\n                // This tracks the originating layer for the variant\n                // For example:\n                // .sm:underline {} is a variant of something in the utilities layer\n                // .sm:container {} is a variant of the container component\n                clone.nodes[0].raws.tailwind = {\n                    ...clone.nodes[0].raws.tailwind,\n                    parentLayer: meta.layer\n                };\n                var _collectedFormats;\n                let withOffset = [\n                    {\n                        ...meta,\n                        sort: context.offsets.applyVariantOffset(meta.sort, variantSort, Object.assign(args, context.variantOptions.get(variant))),\n                        collectedFormats: ((_collectedFormats = meta.collectedFormats) !== null && _collectedFormats !== void 0 ? _collectedFormats : []).concat(collectedFormats),\n                        isArbitraryVariant: isArbitraryValue(variant)\n                    },\n                    clone.nodes[0]\n                ];\n                result.push(withOffset);\n            }\n        }\n        return result;\n    }\n    return [];\n}\nfunction parseRules(rule, cache, options = {}) {\n    // PostCSS node\n    if (!(0, _isPlainObject.default)(rule) && !Array.isArray(rule)) {\n        return [\n            [\n                rule\n            ],\n            options\n        ];\n    }\n    // Tuple\n    if (Array.isArray(rule)) {\n        return parseRules(rule[0], cache, rule[1]);\n    }\n    // Simple object\n    if (!cache.has(rule)) {\n        cache.set(rule, (0, _parseObjectStyles.default)(rule));\n    }\n    return [\n        cache.get(rule),\n        options\n    ];\n}\nconst IS_VALID_PROPERTY_NAME = /^[a-z_-]/;\nfunction isValidPropName(name) {\n    return IS_VALID_PROPERTY_NAME.test(name);\n}\n/**\n * @param {string} declaration\n * @returns {boolean}\n */ function looksLikeUri(declaration) {\n    // Quick bailout for obvious non-urls\n    // This doesn't support schemes that don't use a leading // but that's unlikely to be a problem\n    if (!declaration.includes(\"://\")) {\n        return false;\n    }\n    try {\n        const url = new URL(declaration);\n        return url.scheme !== \"\" && url.host !== \"\";\n    } catch (err) {\n        // Definitely not a valid url\n        return false;\n    }\n}\nfunction isParsableNode(node) {\n    let isParsable = true;\n    node.walkDecls((decl)=>{\n        if (!isParsableCssValue(decl.name, decl.value)) {\n            isParsable = false;\n            return false;\n        }\n    });\n    return isParsable;\n}\nfunction isParsableCssValue(property, value) {\n    // We don't want to to treat [https://example.com] as a custom property\n    // Even though, according to the CSS grammar, it's a totally valid CSS declaration\n    // So we short-circuit here by checking if the custom property looks like a url\n    if (looksLikeUri(`${property}:${value}`)) {\n        return false;\n    }\n    try {\n        _postcss.default.parse(`a{${property}:${value}}`).toResult();\n        return true;\n    } catch (err) {\n        return false;\n    }\n}\nfunction extractArbitraryProperty(classCandidate, context) {\n    var ref;\n    let [, property, value] = (ref = classCandidate.match(/^\\[([a-zA-Z0-9-_]+):(\\S+)\\]$/)) !== null && ref !== void 0 ? ref : [];\n    if (value === undefined) {\n        return null;\n    }\n    if (!isValidPropName(property)) {\n        return null;\n    }\n    if (!(0, _isValidArbitraryValue.default)(value)) {\n        return null;\n    }\n    let normalized = (0, _dataTypes.normalize)(value);\n    if (!isParsableCssValue(property, normalized)) {\n        return null;\n    }\n    let sort = context.offsets.arbitraryProperty();\n    return [\n        [\n            {\n                sort,\n                layer: \"utilities\"\n            },\n            ()=>({\n                    [(0, _nameClass.asClass)(classCandidate)]: {\n                        [property]: normalized\n                    }\n                })\n        ]\n    ];\n}\nfunction* resolveMatchedPlugins(classCandidate, context) {\n    if (context.candidateRuleMap.has(classCandidate)) {\n        yield [\n            context.candidateRuleMap.get(classCandidate),\n            \"DEFAULT\"\n        ];\n    }\n    yield* function*(arbitraryPropertyRule) {\n        if (arbitraryPropertyRule !== null) {\n            yield [\n                arbitraryPropertyRule,\n                \"DEFAULT\"\n            ];\n        }\n    }(extractArbitraryProperty(classCandidate, context));\n    let candidatePrefix = classCandidate;\n    let negative = false;\n    const twConfigPrefix = context.tailwindConfig.prefix;\n    const twConfigPrefixLen = twConfigPrefix.length;\n    const hasMatchingPrefix = candidatePrefix.startsWith(twConfigPrefix) || candidatePrefix.startsWith(`-${twConfigPrefix}`);\n    if (candidatePrefix[twConfigPrefixLen] === \"-\" && hasMatchingPrefix) {\n        negative = true;\n        candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1);\n    }\n    if (negative && context.candidateRuleMap.has(candidatePrefix)) {\n        yield [\n            context.candidateRuleMap.get(candidatePrefix),\n            \"-DEFAULT\"\n        ];\n    }\n    for (let [prefix, modifier] of candidatePermutations(candidatePrefix)){\n        if (context.candidateRuleMap.has(prefix)) {\n            yield [\n                context.candidateRuleMap.get(prefix),\n                negative ? `-${modifier}` : modifier\n            ];\n        }\n    }\n}\nfunction splitWithSeparator(input, separator) {\n    if (input === _sharedState.NOT_ON_DEMAND) {\n        return [\n            _sharedState.NOT_ON_DEMAND\n        ];\n    }\n    return (0, _splitAtTopLevelOnlyJs.splitAtTopLevelOnly)(input, separator);\n}\nfunction* recordCandidates(matches, classCandidate) {\n    for (const match of matches){\n        var ref;\n        var ref1;\n        match[1].raws.tailwind = {\n            ...match[1].raws.tailwind,\n            classCandidate,\n            preserveSource: (ref1 = (ref = match[0].options) === null || ref === void 0 ? void 0 : ref.preserveSource) !== null && ref1 !== void 0 ? ref1 : false\n        };\n        yield match;\n    }\n}\nfunction* resolveMatches(candidate, context, original = candidate) {\n    let separator = context.tailwindConfig.separator;\n    let [classCandidate, ...variants] = splitWithSeparator(candidate, separator).reverse();\n    let important = false;\n    if (classCandidate.startsWith(\"!\")) {\n        important = true;\n        classCandidate = classCandidate.slice(1);\n    }\n    if ((0, _featureFlags.flagEnabled)(context.tailwindConfig, \"variantGrouping\")) {\n        if (classCandidate.startsWith(\"(\") && classCandidate.endsWith(\")\")) {\n            let base = variants.slice().reverse().join(separator);\n            for (let part of (0, _splitAtTopLevelOnlyJs.splitAtTopLevelOnly)(classCandidate.slice(1, -1), \",\")){\n                yield* resolveMatches(base + separator + part, context, original);\n            }\n        }\n    }\n    // TODO: Reintroduce this in ways that doesn't break on false positives\n    // function sortAgainst(toSort, against) {\n    //   return toSort.slice().sort((a, z) => {\n    //     return bigSign(against.get(a)[0] - against.get(z)[0])\n    //   })\n    // }\n    // let sorted = sortAgainst(variants, context.variantMap)\n    // if (sorted.toString() !== variants.toString()) {\n    //   let corrected = sorted.reverse().concat(classCandidate).join(':')\n    //   throw new Error(`Class ${candidate} should be written as ${corrected}`)\n    // }\n    for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context)){\n        let matches = [];\n        let typesByMatches = new Map();\n        let [plugins, modifier] = matchedPlugins;\n        let isOnlyPlugin = plugins.length === 1;\n        for (let [sort, plugin] of plugins){\n            let matchesPerPlugin = [];\n            if (typeof plugin === \"function\") {\n                for (let ruleSet of [].concat(plugin(modifier, {\n                    isOnlyPlugin\n                }))){\n                    let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);\n                    for (let rule of rules){\n                        matchesPerPlugin.push([\n                            {\n                                ...sort,\n                                options: {\n                                    ...sort.options,\n                                    ...options\n                                }\n                            },\n                            rule\n                        ]);\n                    }\n                }\n            } else if (modifier === \"DEFAULT\" || modifier === \"-DEFAULT\") {\n                let ruleSet1 = plugin;\n                let [rules1, options1] = parseRules(ruleSet1, context.postCssNodeCache);\n                for (let rule1 of rules1){\n                    matchesPerPlugin.push([\n                        {\n                            ...sort,\n                            options: {\n                                ...sort.options,\n                                ...options1\n                            }\n                        },\n                        rule1\n                    ]);\n                }\n            }\n            if (matchesPerPlugin.length > 0) {\n                var ref;\n                var ref1, _options;\n                let matchingTypes = Array.from((0, _pluginUtils.getMatchingTypes)((ref1 = (ref = sort.options) === null || ref === void 0 ? void 0 : ref.types) !== null && ref1 !== void 0 ? ref1 : [], modifier, (_options = sort.options) !== null && _options !== void 0 ? _options : {}, context.tailwindConfig)).map(([_, type])=>type);\n                if (matchingTypes.length > 0) {\n                    typesByMatches.set(matchesPerPlugin, matchingTypes);\n                }\n                matches.push(matchesPerPlugin);\n            }\n        }\n        if (isArbitraryValue(modifier)) {\n            if (matches.length > 1) {\n                // Partition plugins in 2 categories so that we can start searching in the plugins that\n                // don't have `any` as a type first.\n                let [withAny, withoutAny] = matches.reduce((group, plugin)=>{\n                    let hasAnyType = plugin.some(([{ options  }])=>options.types.some(({ type  })=>type === \"any\"));\n                    if (hasAnyType) {\n                        group[0].push(plugin);\n                    } else {\n                        group[1].push(plugin);\n                    }\n                    return group;\n                }, [\n                    [],\n                    []\n                ]);\n                function findFallback(matches) {\n                    // If only a single plugin matches, let's take that one\n                    if (matches.length === 1) {\n                        return matches[0];\n                    }\n                    // Otherwise, find the plugin that creates a valid rule given the arbitrary value, and\n                    // also has the correct type which preferOnConflicts the plugin in case of clashes.\n                    return matches.find((rules)=>{\n                        let matchingTypes = typesByMatches.get(rules);\n                        return rules.some(([{ options  }, rule])=>{\n                            if (!isParsableNode(rule)) {\n                                return false;\n                            }\n                            return options.types.some(({ type , preferOnConflict  })=>matchingTypes.includes(type) && preferOnConflict);\n                        });\n                    });\n                }\n                var ref2;\n                // Try to find a fallback plugin, because we already know that multiple plugins matched for\n                // the given arbitrary value.\n                let fallback = (ref2 = findFallback(withoutAny)) !== null && ref2 !== void 0 ? ref2 : findFallback(withAny);\n                if (fallback) {\n                    matches = [\n                        fallback\n                    ];\n                } else {\n                    var ref3;\n                    let typesPerPlugin = matches.map((match)=>new Set([\n                            ...(ref3 = typesByMatches.get(match)) !== null && ref3 !== void 0 ? ref3 : []\n                        ]));\n                    // Remove duplicates, so that we can detect proper unique types for each plugin.\n                    for (let pluginTypes of typesPerPlugin){\n                        for (let type of pluginTypes){\n                            let removeFromOwnGroup = false;\n                            for (let otherGroup of typesPerPlugin){\n                                if (pluginTypes === otherGroup) continue;\n                                if (otherGroup.has(type)) {\n                                    otherGroup.delete(type);\n                                    removeFromOwnGroup = true;\n                                }\n                            }\n                            if (removeFromOwnGroup) pluginTypes.delete(type);\n                        }\n                    }\n                    let messages = [];\n                    for (let [idx, group] of typesPerPlugin.entries()){\n                        for (let type1 of group){\n                            let rules2 = matches[idx].map(([, rule])=>rule).flat().map((rule)=>rule.toString().split(\"\\n\").slice(1, -1) // Remove selector and closing '}'\n                                .map((line)=>line.trim()).map((x)=>`      ${x}`) // Re-indent\n                                .join(\"\\n\")).join(\"\\n\\n\");\n                            messages.push(`  Use \\`${candidate.replace(\"[\", `[${type1}:`)}\\` for \\`${rules2.trim()}\\``);\n                            break;\n                        }\n                    }\n                    _log.default.warn([\n                        `The class \\`${candidate}\\` is ambiguous and matches multiple utilities.`,\n                        ...messages,\n                        `If this is content and not a class, replace it with \\`${candidate.replace(\"[\", \"&lsqb;\").replace(\"]\", \"&rsqb;\")}\\` to silence this warning.`\n                    ]);\n                    continue;\n                }\n            }\n            matches = matches.map((list)=>list.filter((match)=>isParsableNode(match[1])));\n        }\n        matches = matches.flat();\n        matches = Array.from(recordCandidates(matches, classCandidate));\n        matches = applyPrefix(matches, context);\n        if (important) {\n            matches = applyImportant(matches, classCandidate);\n        }\n        for (let variant of variants){\n            matches = applyVariant(variant, matches, context);\n        }\n        for (let match of matches){\n            match[1].raws.tailwind = {\n                ...match[1].raws.tailwind,\n                candidate\n            };\n            // Apply final format selector\n            if (match[0].collectedFormats) {\n                let finalFormat = (0, _formatVariantSelector.formatVariantSelector)(\"&\", ...match[0].collectedFormats);\n                let container = _postcss.default.root({\n                    nodes: [\n                        match[1].clone()\n                    ]\n                });\n                container.walkRules((rule)=>{\n                    var ref;\n                    if (inKeyframes(rule)) return;\n                    var ref1;\n                    rule.selector = (0, _formatVariantSelector.finalizeSelector)(finalFormat, {\n                        selector: rule.selector,\n                        candidate: original,\n                        base: candidate.split(new RegExp(`\\\\${(ref1 = context === null || context === void 0 ? void 0 : (ref = context.tailwindConfig) === null || ref === void 0 ? void 0 : ref.separator) !== null && ref1 !== void 0 ? ref1 : \":\"}(?![^[]*\\\\])`)).pop(),\n                        isArbitraryVariant: match[0].isArbitraryVariant,\n                        context\n                    });\n                });\n                match[1] = container.nodes[0];\n            }\n            yield match;\n        }\n    }\n}\nfunction inKeyframes(rule) {\n    return rule.parent && rule.parent.type === \"atrule\" && rule.parent.name === \"keyframes\";\n}\nfunction getImportantStrategy(important) {\n    if (important === true) {\n        return (rule)=>{\n            if (inKeyframes(rule)) {\n                return;\n            }\n            rule.walkDecls((d)=>{\n                if (d.parent.type === \"rule\" && !inKeyframes(d.parent)) {\n                    d.important = true;\n                }\n            });\n        };\n    }\n    if (typeof important === \"string\") {\n        return (rule)=>{\n            if (inKeyframes(rule)) {\n                return;\n            }\n            rule.selectors = rule.selectors.map((selector)=>{\n                return `${important} ${selector}`;\n            });\n        };\n    }\n}\nfunction generateRules(candidates, context) {\n    let allRules = [];\n    let strategy = getImportantStrategy(context.tailwindConfig.important);\n    for (let candidate of candidates){\n        if (context.notClassCache.has(candidate)) {\n            continue;\n        }\n        if (context.candidateRuleCache.has(candidate)) {\n            allRules = allRules.concat(Array.from(context.candidateRuleCache.get(candidate)));\n            continue;\n        }\n        let matches = Array.from(resolveMatches(candidate, context));\n        if (matches.length === 0) {\n            context.notClassCache.add(candidate);\n            continue;\n        }\n        context.classCache.set(candidate, matches);\n        var ref;\n        let rules = (ref = context.candidateRuleCache.get(candidate)) !== null && ref !== void 0 ? ref : new Set();\n        context.candidateRuleCache.set(candidate, rules);\n        for (const match of matches){\n            let [{ sort , options  }, rule] = match;\n            if (options.respectImportant && strategy) {\n                let container = _postcss.default.root({\n                    nodes: [\n                        rule.clone()\n                    ]\n                });\n                container.walkRules(strategy);\n                rule = container.nodes[0];\n            }\n            let newEntry = [\n                sort,\n                rule\n            ];\n            rules.add(newEntry);\n            context.ruleCache.add(newEntry);\n            allRules.push(newEntry);\n        }\n    }\n    return allRules;\n}\nfunction isArbitraryValue(input) {\n    return input.startsWith(\"[\") && input.endsWith(\"]\");\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}