{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  selectorFunctions: () => selectorFunctions,\n  formatVariantSelector: () => formatVariantSelector,\n  finalizeSelector: () => finalizeSelector\n});\nconst _postcssSelectorParser = /*#__PURE__*/_interopRequireDefault(require(\"postcss-selector-parser\"));\nconst _unesc = /*#__PURE__*/_interopRequireDefault(require(\"postcss-selector-parser/dist/util/unesc\"));\nconst _escapeClassName = /*#__PURE__*/_interopRequireDefault(require(\"../util/escapeClassName\"));\nconst _prefixSelector = /*#__PURE__*/_interopRequireDefault(require(\"../util/prefixSelector\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar ref;\nlet MERGE = \":merge\";\nlet PARENT = \"&\";\nlet selectorFunctions = new Set([MERGE]);\nfunction formatVariantSelector(current) {\n  for (var _len = arguments.length, others = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    others[_key - 1] = arguments[_key];\n  }\n  for (let other of others) {\n    let incomingValue = resolveFunctionArgument(other, MERGE);\n    if (incomingValue !== null) {\n      let existingValue = resolveFunctionArgument(current, MERGE, incomingValue);\n      if (existingValue !== null) {\n        let existingTarget = `${MERGE}(${incomingValue})`;\n        let splitIdx = other.indexOf(existingTarget);\n        let addition = other.slice(splitIdx + existingTarget.length).split(\" \")[0];\n        current = current.replace(existingTarget, existingTarget + addition);\n        continue;\n      }\n    }\n    current = other.replace(PARENT, current);\n  }\n  return current;\n}\n/**\n * Given any node in a selector this gets the \"simple\" selector it's a part of\n * A simple selector is just a list of nodes without any combinators\n * Technically :is(), :not(), :has(), etc… can have combinators but those are nested\n * inside the relevant node and won't be picked up so they're fine to ignore\n *\n * @param {import('postcss-selector-parser').Node} node\n * @returns {import('postcss-selector-parser').Node[]}\n **/\nfunction simpleSelectorForNode(node) {\n  /** @type {import('postcss-selector-parser').Node[]} */let nodes = [];\n  // Walk backwards until we hit a combinator node (or the start)\n  while (node.prev() && node.prev().type !== \"combinator\") {\n    node = node.prev();\n  }\n  // Now record all non-combinator nodes until we hit one (or the end)\n  while (node && node.type !== \"combinator\") {\n    nodes.push(node);\n    node = node.next();\n  }\n  return nodes;\n}\n/**\n * Resorts the nodes in a selector to ensure they're in the correct order\n * Tags go before classes, and pseudo classes go after classes\n *\n * @param {import('postcss-selector-parser').Selector} sel\n * @returns {import('postcss-selector-parser').Selector}\n **/\nfunction resortSelector(sel) {\n  sel.sort((a, b) => {\n    if (a.type === \"tag\" && b.type === \"class\") {\n      return -1;\n    } else if (a.type === \"class\" && b.type === \"tag\") {\n      return 1;\n    } else if (a.type === \"class\" && b.type === \"pseudo\" && b.value.startsWith(\"::\")) {\n      return -1;\n    } else if (a.type === \"pseudo\" && a.value.startsWith(\"::\") && b.type === \"class\") {\n      return 1;\n    }\n    return sel.index(a) - sel.index(b);\n  });\n  return sel;\n}\nfunction eliminateIrrelevantSelectors(sel, base) {\n  let hasClassesMatchingCandidate = false;\n  sel.walk(child => {\n    if (child.type === \"class\" && child.value === base) {\n      hasClassesMatchingCandidate = true;\n      return false // Stop walking\n      ;\n    }\n  });\n\n  if (!hasClassesMatchingCandidate) {\n    sel.remove();\n  }\n  // We do NOT recursively eliminate sub selectors that don't have the base class\n  // as this is NOT a safe operation. For example, if we have:\n  // `.space-x-2 > :not([hidden]) ~ :not([hidden])`\n  // We cannot remove the [hidden] from the :not() because it would change the\n  // meaning of the selector.\n  // TODO: Can we do this for :matches, :is, and :where?\n}\n\nvar ref1;\nfunction finalizeSelector(format, _ref) {\n  let {\n    selector,\n    candidate,\n    context,\n    isArbitraryVariant,\n    // Split by the separator, but ignore the separator inside square brackets:\n    //\n    // E.g.: dark:lg:hover:[paint-order:markers]\n    //           ┬  ┬     ┬            ┬\n    //           │  │     │            ╰── We will not split here\n    //           ╰──┴─────┴─────────────── We will split here\n    //\n    base = candidate.split(new RegExp(`\\\\${(ref1 = context === null || context === void 0 ? void 0 : (ref = context.tailwindConfig) === null || ref === void 0 ? void 0 : ref.separator) !== null && ref1 !== void 0 ? ref1 : \":\"}(?![^[]*\\\\])`)).pop()\n  } = _ref;\n  var ref2;\n  let ast = (0, _postcssSelectorParser.default)().astSync(selector);\n  // We explicitly DO NOT prefix classes in arbitrary variants\n  if ((context === null || context === void 0 ? void 0 : (ref2 = context.tailwindConfig) === null || ref2 === void 0 ? void 0 : ref2.prefix) && !isArbitraryVariant) {\n    format = (0, _prefixSelector.default)(context.tailwindConfig.prefix, format);\n  }\n  format = format.replace(PARENT, `.${(0, _escapeClassName.default)(candidate)}`);\n  let formatAst = (0, _postcssSelectorParser.default)().astSync(format);\n  // Remove extraneous selectors that do not include the base class/candidate being matched against\n  // For example if we have a utility defined `.a, .b { color: red}`\n  // And the formatted variant is sm:b then we want the final selector to be `.sm\\:b` and not `.a, .sm\\:b`\n  ast.each(sel => eliminateIrrelevantSelectors(sel, base));\n  // Normalize escaped classes, e.g.:\n  //\n  // The idea would be to replace the escaped `base` in the selector with the\n  // `format`. However, in css you can escape the same selector in a few\n  // different ways. This would result in different strings and therefore we\n  // can't replace it properly.\n  //\n  //               base: bg-[rgb(255,0,0)]\n  //   base in selector: bg-\\\\[rgb\\\\(255\\\\,0\\\\,0\\\\)\\\\]\n  //       escaped base: bg-\\\\[rgb\\\\(255\\\\2c 0\\\\2c 0\\\\)\\\\]\n  //\n  ast.walkClasses(node => {\n    if (node.raws && node.value.includes(base)) {\n      node.raws.value = (0, _escapeClassName.default)((0, _unesc.default)(node.raws.value));\n    }\n  });\n  let simpleStart = _postcssSelectorParser.default.comment({\n    value: \"/*__simple__*/\"\n  });\n  let simpleEnd = _postcssSelectorParser.default.comment({\n    value: \"/*__simple__*/\"\n  });\n  // We can safely replace the escaped base now, since the `base` section is\n  // now in a normalized escaped value.\n  ast.walkClasses(node => {\n    if (node.value !== base) {\n      return;\n    }\n    let parent = node.parent;\n    let formatNodes = formatAst.nodes[0].nodes;\n    // Perf optimization: if the parent is a single class we can just replace it and be done\n    if (parent.nodes.length === 1) {\n      node.replaceWith(...formatNodes);\n      return;\n    }\n    let simpleSelector = simpleSelectorForNode(node);\n    parent.insertBefore(simpleSelector[0], simpleStart);\n    parent.insertAfter(simpleSelector[simpleSelector.length - 1], simpleEnd);\n    for (let child of formatNodes) {\n      parent.insertBefore(simpleSelector[0], child);\n    }\n    node.remove();\n    // Re-sort the simple selector to ensure it's in the correct order\n    simpleSelector = simpleSelectorForNode(simpleStart);\n    let firstNode = parent.index(simpleStart);\n    parent.nodes.splice(firstNode, simpleSelector.length, ...resortSelector(_postcssSelectorParser.default.selector({\n      nodes: simpleSelector\n    })).nodes);\n    simpleStart.remove();\n    simpleEnd.remove();\n  });\n  // This will make sure to move pseudo's to the correct spot (the end for\n  // pseudo elements) because otherwise the selector will never work\n  // anyway.\n  //\n  // E.g.:\n  //  - `before:hover:text-center` would result in `.before\\:hover\\:text-center:hover::before`\n  //  - `hover:before:text-center` would result in `.hover\\:before\\:text-center:hover::before`\n  //\n  // `::before:hover` doesn't work, which means that we can make it work for you by flipping the order.\n  function collectPseudoElements(selector) {\n    let nodes = [];\n    for (let node of selector.nodes) {\n      if (isPseudoElement(node)) {\n        nodes.push(node);\n        selector.removeChild(node);\n      }\n      if (node === null || node === void 0 ? void 0 : node.nodes) {\n        nodes.push(...collectPseudoElements(node));\n      }\n    }\n    return nodes;\n  }\n  // Remove unnecessary pseudo selectors that we used as placeholders\n  ast.each(selector => {\n    selector.walkPseudos(p => {\n      if (selectorFunctions.has(p.value)) {\n        p.replaceWith(p.nodes);\n      }\n    });\n    let pseudoElements = collectPseudoElements(selector);\n    if (pseudoElements.length > 0) {\n      selector.nodes.push(pseudoElements.sort(sortSelector));\n    }\n  });\n  return ast.toString();\n}\n// Note: As a rule, double colons (::) should be used instead of a single colon\n// (:). This distinguishes pseudo-classes from pseudo-elements. However, since\n// this distinction was not present in older versions of the W3C spec, most\n// browsers support both syntaxes for the original pseudo-elements.\nlet pseudoElementsBC = [\":before\", \":after\", \":first-line\", \":first-letter\"];\n// These pseudo-elements _can_ be combined with other pseudo selectors AND the order does matter.\nlet pseudoElementExceptions = [\"::file-selector-button\"];\n// This will make sure to move pseudo's to the correct spot (the end for\n// pseudo elements) because otherwise the selector will never work\n// anyway.\n//\n// E.g.:\n//  - `before:hover:text-center` would result in `.before\\:hover\\:text-center:hover::before`\n//  - `hover:before:text-center` would result in `.hover\\:before\\:text-center:hover::before`\n//\n// `::before:hover` doesn't work, which means that we can make it work\n// for you by flipping the order.\nfunction sortSelector(a, z) {\n  // Both nodes are non-pseudo's so we can safely ignore them and keep\n  // them in the same order.\n  if (a.type !== \"pseudo\" && z.type !== \"pseudo\") {\n    return 0;\n  }\n  // If one of them is a combinator, we need to keep it in the same order\n  // because that means it will start a new \"section\" in the selector.\n  if (a.type === \"combinator\" ^ z.type === \"combinator\") {\n    return 0;\n  }\n  // One of the items is a pseudo and the other one isn't. Let's move\n  // the pseudo to the right.\n  if (a.type === \"pseudo\" ^ z.type === \"pseudo\") {\n    return (a.type === \"pseudo\") - (z.type === \"pseudo\");\n  }\n  // Both are pseudo's, move the pseudo elements (except for\n  // ::file-selector-button) to the right.\n  return isPseudoElement(a) - isPseudoElement(z);\n}\nfunction isPseudoElement(node) {\n  if (node.type !== \"pseudo\") return false;\n  if (pseudoElementExceptions.includes(node.value)) return false;\n  return node.value.startsWith(\"::\") || pseudoElementsBC.includes(node.value);\n}\nfunction resolveFunctionArgument(haystack, needle, arg) {\n  let startIdx = haystack.indexOf(arg ? `${needle}(${arg})` : needle);\n  if (startIdx === -1) return null;\n  // Start inside the `(`\n  startIdx += needle.length + 1;\n  let target = \"\";\n  let count = 0;\n  for (let char of haystack.slice(startIdx)) {\n    if (char !== \"(\" && char !== \")\") {\n      target += char;\n    } else if (char === \"(\") {\n      target += char;\n      count++;\n    } else if (char === \")\") {\n      if (--count < 0) break; // unbalanced\n      target += char;\n    }\n  }\n  return target;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_export","target","all","name","enumerable","get","selectorFunctions","formatVariantSelector","finalizeSelector","_postcssSelectorParser","_interopRequireDefault","require","_unesc","_escapeClassName","_prefixSelector","obj","__esModule","default","ref","MERGE","PARENT","Set","current","others","other","incomingValue","resolveFunctionArgument","existingValue","existingTarget","splitIdx","indexOf","addition","slice","length","split","replace","simpleSelectorForNode","node","nodes","prev","type","push","next","resortSelector","sel","sort","a","b","startsWith","index","eliminateIrrelevantSelectors","base","hasClassesMatchingCandidate","walk","child","remove","ref1","format","selector","candidate","context","isArbitraryVariant","RegExp","tailwindConfig","separator","pop","ref2","ast","astSync","prefix","formatAst","each","walkClasses","raws","includes","simpleStart","comment","simpleEnd","parent","formatNodes","replaceWith","simpleSelector","insertBefore","insertAfter","firstNode","splice","collectPseudoElements","isPseudoElement","removeChild","walkPseudos","p","has","pseudoElements","sortSelector","toString","pseudoElementsBC","pseudoElementExceptions","z","haystack","needle","arg","startIdx","count","char"],"sources":["/home/sahithya/bios/login/fronte/node_modules/tailwindcss/lib/util/formatVariantSelector.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    selectorFunctions: ()=>selectorFunctions,\n    formatVariantSelector: ()=>formatVariantSelector,\n    finalizeSelector: ()=>finalizeSelector\n});\nconst _postcssSelectorParser = /*#__PURE__*/ _interopRequireDefault(require(\"postcss-selector-parser\"));\nconst _unesc = /*#__PURE__*/ _interopRequireDefault(require(\"postcss-selector-parser/dist/util/unesc\"));\nconst _escapeClassName = /*#__PURE__*/ _interopRequireDefault(require(\"../util/escapeClassName\"));\nconst _prefixSelector = /*#__PURE__*/ _interopRequireDefault(require(\"../util/prefixSelector\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nvar ref;\nlet MERGE = \":merge\";\nlet PARENT = \"&\";\nlet selectorFunctions = new Set([\n    MERGE\n]);\nfunction formatVariantSelector(current, ...others) {\n    for (let other of others){\n        let incomingValue = resolveFunctionArgument(other, MERGE);\n        if (incomingValue !== null) {\n            let existingValue = resolveFunctionArgument(current, MERGE, incomingValue);\n            if (existingValue !== null) {\n                let existingTarget = `${MERGE}(${incomingValue})`;\n                let splitIdx = other.indexOf(existingTarget);\n                let addition = other.slice(splitIdx + existingTarget.length).split(\" \")[0];\n                current = current.replace(existingTarget, existingTarget + addition);\n                continue;\n            }\n        }\n        current = other.replace(PARENT, current);\n    }\n    return current;\n}\n/**\n * Given any node in a selector this gets the \"simple\" selector it's a part of\n * A simple selector is just a list of nodes without any combinators\n * Technically :is(), :not(), :has(), etc… can have combinators but those are nested\n * inside the relevant node and won't be picked up so they're fine to ignore\n *\n * @param {import('postcss-selector-parser').Node} node\n * @returns {import('postcss-selector-parser').Node[]}\n **/ function simpleSelectorForNode(node) {\n    /** @type {import('postcss-selector-parser').Node[]} */ let nodes = [];\n    // Walk backwards until we hit a combinator node (or the start)\n    while(node.prev() && node.prev().type !== \"combinator\"){\n        node = node.prev();\n    }\n    // Now record all non-combinator nodes until we hit one (or the end)\n    while(node && node.type !== \"combinator\"){\n        nodes.push(node);\n        node = node.next();\n    }\n    return nodes;\n}\n/**\n * Resorts the nodes in a selector to ensure they're in the correct order\n * Tags go before classes, and pseudo classes go after classes\n *\n * @param {import('postcss-selector-parser').Selector} sel\n * @returns {import('postcss-selector-parser').Selector}\n **/ function resortSelector(sel) {\n    sel.sort((a, b)=>{\n        if (a.type === \"tag\" && b.type === \"class\") {\n            return -1;\n        } else if (a.type === \"class\" && b.type === \"tag\") {\n            return 1;\n        } else if (a.type === \"class\" && b.type === \"pseudo\" && b.value.startsWith(\"::\")) {\n            return -1;\n        } else if (a.type === \"pseudo\" && a.value.startsWith(\"::\") && b.type === \"class\") {\n            return 1;\n        }\n        return sel.index(a) - sel.index(b);\n    });\n    return sel;\n}\nfunction eliminateIrrelevantSelectors(sel, base) {\n    let hasClassesMatchingCandidate = false;\n    sel.walk((child)=>{\n        if (child.type === \"class\" && child.value === base) {\n            hasClassesMatchingCandidate = true;\n            return false // Stop walking\n            ;\n        }\n    });\n    if (!hasClassesMatchingCandidate) {\n        sel.remove();\n    }\n// We do NOT recursively eliminate sub selectors that don't have the base class\n// as this is NOT a safe operation. For example, if we have:\n// `.space-x-2 > :not([hidden]) ~ :not([hidden])`\n// We cannot remove the [hidden] from the :not() because it would change the\n// meaning of the selector.\n// TODO: Can we do this for :matches, :is, and :where?\n}\nvar ref1;\nfunction finalizeSelector(format, { selector , candidate , context , isArbitraryVariant , // Split by the separator, but ignore the separator inside square brackets:\n//\n// E.g.: dark:lg:hover:[paint-order:markers]\n//           ┬  ┬     ┬            ┬\n//           │  │     │            ╰── We will not split here\n//           ╰──┴─────┴─────────────── We will split here\n//\nbase =candidate.split(new RegExp(`\\\\${(ref1 = context === null || context === void 0 ? void 0 : (ref = context.tailwindConfig) === null || ref === void 0 ? void 0 : ref.separator) !== null && ref1 !== void 0 ? ref1 : \":\"}(?![^[]*\\\\])`)).pop()  }) {\n    var ref2;\n    let ast = (0, _postcssSelectorParser.default)().astSync(selector);\n    // We explicitly DO NOT prefix classes in arbitrary variants\n    if ((context === null || context === void 0 ? void 0 : (ref2 = context.tailwindConfig) === null || ref2 === void 0 ? void 0 : ref2.prefix) && !isArbitraryVariant) {\n        format = (0, _prefixSelector.default)(context.tailwindConfig.prefix, format);\n    }\n    format = format.replace(PARENT, `.${(0, _escapeClassName.default)(candidate)}`);\n    let formatAst = (0, _postcssSelectorParser.default)().astSync(format);\n    // Remove extraneous selectors that do not include the base class/candidate being matched against\n    // For example if we have a utility defined `.a, .b { color: red}`\n    // And the formatted variant is sm:b then we want the final selector to be `.sm\\:b` and not `.a, .sm\\:b`\n    ast.each((sel)=>eliminateIrrelevantSelectors(sel, base));\n    // Normalize escaped classes, e.g.:\n    //\n    // The idea would be to replace the escaped `base` in the selector with the\n    // `format`. However, in css you can escape the same selector in a few\n    // different ways. This would result in different strings and therefore we\n    // can't replace it properly.\n    //\n    //               base: bg-[rgb(255,0,0)]\n    //   base in selector: bg-\\\\[rgb\\\\(255\\\\,0\\\\,0\\\\)\\\\]\n    //       escaped base: bg-\\\\[rgb\\\\(255\\\\2c 0\\\\2c 0\\\\)\\\\]\n    //\n    ast.walkClasses((node)=>{\n        if (node.raws && node.value.includes(base)) {\n            node.raws.value = (0, _escapeClassName.default)((0, _unesc.default)(node.raws.value));\n        }\n    });\n    let simpleStart = _postcssSelectorParser.default.comment({\n        value: \"/*__simple__*/\"\n    });\n    let simpleEnd = _postcssSelectorParser.default.comment({\n        value: \"/*__simple__*/\"\n    });\n    // We can safely replace the escaped base now, since the `base` section is\n    // now in a normalized escaped value.\n    ast.walkClasses((node)=>{\n        if (node.value !== base) {\n            return;\n        }\n        let parent = node.parent;\n        let formatNodes = formatAst.nodes[0].nodes;\n        // Perf optimization: if the parent is a single class we can just replace it and be done\n        if (parent.nodes.length === 1) {\n            node.replaceWith(...formatNodes);\n            return;\n        }\n        let simpleSelector = simpleSelectorForNode(node);\n        parent.insertBefore(simpleSelector[0], simpleStart);\n        parent.insertAfter(simpleSelector[simpleSelector.length - 1], simpleEnd);\n        for (let child of formatNodes){\n            parent.insertBefore(simpleSelector[0], child);\n        }\n        node.remove();\n        // Re-sort the simple selector to ensure it's in the correct order\n        simpleSelector = simpleSelectorForNode(simpleStart);\n        let firstNode = parent.index(simpleStart);\n        parent.nodes.splice(firstNode, simpleSelector.length, ...resortSelector(_postcssSelectorParser.default.selector({\n            nodes: simpleSelector\n        })).nodes);\n        simpleStart.remove();\n        simpleEnd.remove();\n    });\n    // This will make sure to move pseudo's to the correct spot (the end for\n    // pseudo elements) because otherwise the selector will never work\n    // anyway.\n    //\n    // E.g.:\n    //  - `before:hover:text-center` would result in `.before\\:hover\\:text-center:hover::before`\n    //  - `hover:before:text-center` would result in `.hover\\:before\\:text-center:hover::before`\n    //\n    // `::before:hover` doesn't work, which means that we can make it work for you by flipping the order.\n    function collectPseudoElements(selector) {\n        let nodes = [];\n        for (let node of selector.nodes){\n            if (isPseudoElement(node)) {\n                nodes.push(node);\n                selector.removeChild(node);\n            }\n            if (node === null || node === void 0 ? void 0 : node.nodes) {\n                nodes.push(...collectPseudoElements(node));\n            }\n        }\n        return nodes;\n    }\n    // Remove unnecessary pseudo selectors that we used as placeholders\n    ast.each((selector)=>{\n        selector.walkPseudos((p)=>{\n            if (selectorFunctions.has(p.value)) {\n                p.replaceWith(p.nodes);\n            }\n        });\n        let pseudoElements = collectPseudoElements(selector);\n        if (pseudoElements.length > 0) {\n            selector.nodes.push(pseudoElements.sort(sortSelector));\n        }\n    });\n    return ast.toString();\n}\n// Note: As a rule, double colons (::) should be used instead of a single colon\n// (:). This distinguishes pseudo-classes from pseudo-elements. However, since\n// this distinction was not present in older versions of the W3C spec, most\n// browsers support both syntaxes for the original pseudo-elements.\nlet pseudoElementsBC = [\n    \":before\",\n    \":after\",\n    \":first-line\",\n    \":first-letter\"\n];\n// These pseudo-elements _can_ be combined with other pseudo selectors AND the order does matter.\nlet pseudoElementExceptions = [\n    \"::file-selector-button\"\n];\n// This will make sure to move pseudo's to the correct spot (the end for\n// pseudo elements) because otherwise the selector will never work\n// anyway.\n//\n// E.g.:\n//  - `before:hover:text-center` would result in `.before\\:hover\\:text-center:hover::before`\n//  - `hover:before:text-center` would result in `.hover\\:before\\:text-center:hover::before`\n//\n// `::before:hover` doesn't work, which means that we can make it work\n// for you by flipping the order.\nfunction sortSelector(a, z) {\n    // Both nodes are non-pseudo's so we can safely ignore them and keep\n    // them in the same order.\n    if (a.type !== \"pseudo\" && z.type !== \"pseudo\") {\n        return 0;\n    }\n    // If one of them is a combinator, we need to keep it in the same order\n    // because that means it will start a new \"section\" in the selector.\n    if (a.type === \"combinator\" ^ z.type === \"combinator\") {\n        return 0;\n    }\n    // One of the items is a pseudo and the other one isn't. Let's move\n    // the pseudo to the right.\n    if (a.type === \"pseudo\" ^ z.type === \"pseudo\") {\n        return (a.type === \"pseudo\") - (z.type === \"pseudo\");\n    }\n    // Both are pseudo's, move the pseudo elements (except for\n    // ::file-selector-button) to the right.\n    return isPseudoElement(a) - isPseudoElement(z);\n}\nfunction isPseudoElement(node) {\n    if (node.type !== \"pseudo\") return false;\n    if (pseudoElementExceptions.includes(node.value)) return false;\n    return node.value.startsWith(\"::\") || pseudoElementsBC.includes(node.value);\n}\nfunction resolveFunctionArgument(haystack, needle, arg) {\n    let startIdx = haystack.indexOf(arg ? `${needle}(${arg})` : needle);\n    if (startIdx === -1) return null;\n    // Start inside the `(`\n    startIdx += needle.length + 1;\n    let target = \"\";\n    let count = 0;\n    for (let char of haystack.slice(startIdx)){\n        if (char !== \"(\" && char !== \")\") {\n            target += char;\n        } else if (char === \"(\") {\n            target += char;\n            count++;\n        } else if (char === \")\") {\n            if (--count < 0) break; // unbalanced\n            target += char;\n        }\n    }\n    return target;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}