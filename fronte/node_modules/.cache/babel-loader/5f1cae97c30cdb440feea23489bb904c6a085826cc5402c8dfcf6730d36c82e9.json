{"ast":null,"code":"// @ts-check\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"Offsets\", {\n  enumerable: true,\n  get: () => Offsets\n});\nconst _bigSign = /*#__PURE__*/_interopRequireDefault(require(\"../util/bigSign\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nclass Offsets {\n  constructor() {\n    /**\n    * Offsets for the next rule in a given layer\n    *\n    * @type {Record<Layer, bigint>}\n    */\n    this.offsets = {\n      defaults: 0n,\n      base: 0n,\n      components: 0n,\n      utilities: 0n,\n      variants: 0n,\n      user: 0n\n    };\n    /**\n    * Positions for a given layer\n    *\n    * @type {Record<Layer, bigint>}\n    */\n    this.layerPositions = {\n      defaults: 0n,\n      base: 1n,\n      components: 2n,\n      utilities: 3n,\n      // There isn't technically a \"user\" layer, but we need to give it a position\n      // Because it's used for ordering user-css from @apply\n      user: 4n,\n      variants: 5n\n    };\n    /**\n    * The total number of functions currently registered across all variants (including arbitrary variants)\n    *\n    * @type {bigint}\n    */\n    this.reservedVariantBits = 0n;\n    /**\n    * Positions for a given variant\n    *\n    * @type {Map<string, bigint>}\n    */\n    this.variantOffsets = new Map();\n  }\n  /**\n  * @param {Layer} layer\n  * @returns {RuleOffset}\n  */\n  create(layer) {\n    return {\n      layer,\n      parentLayer: layer,\n      arbitrary: 0n,\n      variants: 0n,\n      parallelIndex: 0n,\n      index: this.offsets[layer]++,\n      options: []\n    };\n  }\n  /**\n  * @returns {RuleOffset}\n  */\n  arbitraryProperty() {\n    return {\n      ...this.create(\"utilities\"),\n      arbitrary: 1n\n    };\n  }\n  /**\n  * Get the offset for a variant\n  *\n  * @param {string} variant\n  * @param {number} index\n  * @returns {RuleOffset}\n  */\n  forVariant(variant) {\n    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let offset = this.variantOffsets.get(variant);\n    if (offset === undefined) {\n      throw new Error(`Cannot find offset for unknown variant ${variant}`);\n    }\n    return {\n      ...this.create(\"variants\"),\n      variants: offset << BigInt(index)\n    };\n  }\n  /**\n  * @param {RuleOffset} rule\n  * @param {RuleOffset} variant\n  * @param {VariantOption} options\n  * @returns {RuleOffset}\n  */\n  applyVariantOffset(rule, variant, options) {\n    return {\n      ...rule,\n      layer: \"variants\",\n      parentLayer: rule.layer === \"variants\" ? rule.parentLayer : rule.layer,\n      variants: rule.variants | variant.variants,\n      options: options.sort ? [].concat(options, rule.options) : rule.options,\n      // TODO: Technically this is wrong. We should be handling parallel index on a per variant basis.\n      // We'll take the max of all the parallel indexes for now.\n      // @ts-ignore\n      parallelIndex: max([rule.parallelIndex, variant.parallelIndex])\n    };\n  }\n  /**\n  * @param {RuleOffset} offset\n  * @param {number} parallelIndex\n  * @returns {RuleOffset}\n  */\n  applyParallelOffset(offset, parallelIndex) {\n    return {\n      ...offset,\n      parallelIndex: BigInt(parallelIndex)\n    };\n  }\n  /**\n  * Each variant gets 1 bit per function / rule registered.\n  * This is because multiple variants can be applied to a single rule and we need to know which ones are present and which ones are not.\n  * Additionally, every unique group of variants is grouped together in the stylesheet.\n  *\n  * This grouping is order-independent. For instance, we do not differentiate between `hover:focus` and `focus:hover`.\n  *\n  * @param {string[]} variants\n  * @param {(name: string) => number} getLength\n  */\n  recordVariants(variants, getLength) {\n    for (let variant of variants) {\n      this.recordVariant(variant, getLength(variant));\n    }\n  }\n  /**\n  * The same as `recordVariants` but for a single arbitrary variant at runtime.\n  * @param {string} variant\n  * @param {number} fnCount\n  *\n  * @returns {RuleOffset} The highest offset for this variant\n  */\n  recordVariant(variant) {\n    let fnCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    this.variantOffsets.set(variant, 1n << this.reservedVariantBits);\n    // Ensure space is reserved for each \"function\" in the parallel variant\n    // by offsetting the next variant by the number of parallel variants\n    // in the one we just added.\n    // Single functions that return parallel variants are NOT handled separately here\n    // They're offset by 1 (or the number of functions) as usual\n    // And each rule returned is tracked separately since the functions are evaluated lazily.\n    // @see `RuleOffset.parallelIndex`\n    this.reservedVariantBits += BigInt(fnCount);\n    return {\n      ...this.create(\"variants\"),\n      variants: 1n << this.reservedVariantBits\n    };\n  }\n  /**\n  * @param {RuleOffset} a\n  * @param {RuleOffset} b\n  * @returns {bigint}\n  */\n  compare(a, b) {\n    // Sort layers together\n    if (a.layer !== b.layer) {\n      return this.layerPositions[a.layer] - this.layerPositions[b.layer];\n    }\n    // Sort based on the sorting function\n    for (let aOptions of a.options) {\n      for (let bOptions of b.options) {\n        if (aOptions.id !== bOptions.id) continue;\n        if (!aOptions.sort || !bOptions.sort) continue;\n        let result = aOptions.sort({\n          value: aOptions.value,\n          modifier: aOptions.modifier\n        }, {\n          value: bOptions.value,\n          modifier: bOptions.modifier\n        });\n        if (result !== 0) return result;\n      }\n    }\n    // Sort variants in the order they were registered\n    if (a.variants !== b.variants) {\n      return a.variants - b.variants;\n    }\n    // Make sure each rule returned by a parallel variant is sorted in ascending order\n    if (a.parallelIndex !== b.parallelIndex) {\n      return a.parallelIndex - b.parallelIndex;\n    }\n    // Always sort arbitrary properties after other utilities\n    if (a.arbitrary !== b.arbitrary) {\n      return a.arbitrary - b.arbitrary;\n    }\n    // Sort utilities, components, etc… in the order they were registered\n    return a.index - b.index;\n  }\n  /**\n  * @template T\n  * @param {[RuleOffset, T][]} list\n  * @returns {[RuleOffset, T][]}\n  */\n  sort(list) {\n    return list.sort((_ref, _ref2) => {\n      let [a] = _ref;\n      let [b] = _ref2;\n      return (0, _bigSign.default)(this.compare(a, b));\n    });\n  }\n}\n/**\n *\n * @param {bigint[]} nums\n * @returns {bigint|null}\n */\nfunction max(nums) {\n  let max = null;\n  for (const num of nums) {\n    max = max !== null && max !== void 0 ? max : num;\n    max = max > num ? max : num;\n  }\n  return max;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","Offsets","_bigSign","_interopRequireDefault","require","obj","__esModule","default","constructor","offsets","defaults","base","components","utilities","variants","user","layerPositions","reservedVariantBits","variantOffsets","Map","create","layer","parentLayer","arbitrary","parallelIndex","index","options","arbitraryProperty","forVariant","variant","offset","undefined","Error","BigInt","applyVariantOffset","rule","sort","concat","max","applyParallelOffset","recordVariants","getLength","recordVariant","fnCount","set","compare","a","b","aOptions","bOptions","id","result","modifier","list","nums","num"],"sources":["/home/sahithya/bios/login/fronte/node_modules/tailwindcss/lib/lib/offsets.js"],"sourcesContent":["// @ts-check\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"Offsets\", {\n    enumerable: true,\n    get: ()=>Offsets\n});\nconst _bigSign = /*#__PURE__*/ _interopRequireDefault(require(\"../util/bigSign\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nclass Offsets {\n    constructor(){\n        /**\n     * Offsets for the next rule in a given layer\n     *\n     * @type {Record<Layer, bigint>}\n     */ this.offsets = {\n            defaults: 0n,\n            base: 0n,\n            components: 0n,\n            utilities: 0n,\n            variants: 0n,\n            user: 0n\n        };\n        /**\n     * Positions for a given layer\n     *\n     * @type {Record<Layer, bigint>}\n     */ this.layerPositions = {\n            defaults: 0n,\n            base: 1n,\n            components: 2n,\n            utilities: 3n,\n            // There isn't technically a \"user\" layer, but we need to give it a position\n            // Because it's used for ordering user-css from @apply\n            user: 4n,\n            variants: 5n\n        };\n        /**\n     * The total number of functions currently registered across all variants (including arbitrary variants)\n     *\n     * @type {bigint}\n     */ this.reservedVariantBits = 0n;\n        /**\n     * Positions for a given variant\n     *\n     * @type {Map<string, bigint>}\n     */ this.variantOffsets = new Map();\n    }\n    /**\n   * @param {Layer} layer\n   * @returns {RuleOffset}\n   */ create(layer) {\n        return {\n            layer,\n            parentLayer: layer,\n            arbitrary: 0n,\n            variants: 0n,\n            parallelIndex: 0n,\n            index: this.offsets[layer]++,\n            options: []\n        };\n    }\n    /**\n   * @returns {RuleOffset}\n   */ arbitraryProperty() {\n        return {\n            ...this.create(\"utilities\"),\n            arbitrary: 1n\n        };\n    }\n    /**\n   * Get the offset for a variant\n   *\n   * @param {string} variant\n   * @param {number} index\n   * @returns {RuleOffset}\n   */ forVariant(variant, index = 0) {\n        let offset = this.variantOffsets.get(variant);\n        if (offset === undefined) {\n            throw new Error(`Cannot find offset for unknown variant ${variant}`);\n        }\n        return {\n            ...this.create(\"variants\"),\n            variants: offset << BigInt(index)\n        };\n    }\n    /**\n   * @param {RuleOffset} rule\n   * @param {RuleOffset} variant\n   * @param {VariantOption} options\n   * @returns {RuleOffset}\n   */ applyVariantOffset(rule, variant, options) {\n        return {\n            ...rule,\n            layer: \"variants\",\n            parentLayer: rule.layer === \"variants\" ? rule.parentLayer : rule.layer,\n            variants: rule.variants | variant.variants,\n            options: options.sort ? [].concat(options, rule.options) : rule.options,\n            // TODO: Technically this is wrong. We should be handling parallel index on a per variant basis.\n            // We'll take the max of all the parallel indexes for now.\n            // @ts-ignore\n            parallelIndex: max([\n                rule.parallelIndex,\n                variant.parallelIndex\n            ])\n        };\n    }\n    /**\n   * @param {RuleOffset} offset\n   * @param {number} parallelIndex\n   * @returns {RuleOffset}\n   */ applyParallelOffset(offset, parallelIndex) {\n        return {\n            ...offset,\n            parallelIndex: BigInt(parallelIndex)\n        };\n    }\n    /**\n   * Each variant gets 1 bit per function / rule registered.\n   * This is because multiple variants can be applied to a single rule and we need to know which ones are present and which ones are not.\n   * Additionally, every unique group of variants is grouped together in the stylesheet.\n   *\n   * This grouping is order-independent. For instance, we do not differentiate between `hover:focus` and `focus:hover`.\n   *\n   * @param {string[]} variants\n   * @param {(name: string) => number} getLength\n   */ recordVariants(variants, getLength) {\n        for (let variant of variants){\n            this.recordVariant(variant, getLength(variant));\n        }\n    }\n    /**\n   * The same as `recordVariants` but for a single arbitrary variant at runtime.\n   * @param {string} variant\n   * @param {number} fnCount\n   *\n   * @returns {RuleOffset} The highest offset for this variant\n   */ recordVariant(variant, fnCount = 1) {\n        this.variantOffsets.set(variant, 1n << this.reservedVariantBits);\n        // Ensure space is reserved for each \"function\" in the parallel variant\n        // by offsetting the next variant by the number of parallel variants\n        // in the one we just added.\n        // Single functions that return parallel variants are NOT handled separately here\n        // They're offset by 1 (or the number of functions) as usual\n        // And each rule returned is tracked separately since the functions are evaluated lazily.\n        // @see `RuleOffset.parallelIndex`\n        this.reservedVariantBits += BigInt(fnCount);\n        return {\n            ...this.create(\"variants\"),\n            variants: 1n << this.reservedVariantBits\n        };\n    }\n    /**\n   * @param {RuleOffset} a\n   * @param {RuleOffset} b\n   * @returns {bigint}\n   */ compare(a, b) {\n        // Sort layers together\n        if (a.layer !== b.layer) {\n            return this.layerPositions[a.layer] - this.layerPositions[b.layer];\n        }\n        // Sort based on the sorting function\n        for (let aOptions of a.options){\n            for (let bOptions of b.options){\n                if (aOptions.id !== bOptions.id) continue;\n                if (!aOptions.sort || !bOptions.sort) continue;\n                let result = aOptions.sort({\n                    value: aOptions.value,\n                    modifier: aOptions.modifier\n                }, {\n                    value: bOptions.value,\n                    modifier: bOptions.modifier\n                });\n                if (result !== 0) return result;\n            }\n        }\n        // Sort variants in the order they were registered\n        if (a.variants !== b.variants) {\n            return a.variants - b.variants;\n        }\n        // Make sure each rule returned by a parallel variant is sorted in ascending order\n        if (a.parallelIndex !== b.parallelIndex) {\n            return a.parallelIndex - b.parallelIndex;\n        }\n        // Always sort arbitrary properties after other utilities\n        if (a.arbitrary !== b.arbitrary) {\n            return a.arbitrary - b.arbitrary;\n        }\n        // Sort utilities, components, etc… in the order they were registered\n        return a.index - b.index;\n    }\n    /**\n   * @template T\n   * @param {[RuleOffset, T][]} list\n   * @returns {[RuleOffset, T][]}\n   */ sort(list) {\n        return list.sort(([a], [b])=>(0, _bigSign.default)(this.compare(a, b)));\n    }\n}\n/**\n *\n * @param {bigint[]} nums\n * @returns {bigint|null}\n */ function max(nums) {\n    let max = null;\n    for (const num of nums){\n        max = max !== null && max !== void 0 ? max : num;\n        max = max > num ? max : num;\n    }\n    return max;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}