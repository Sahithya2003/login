{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  isValidVariantFormatString: () => isValidVariantFormatString,\n  parseVariant: () => parseVariant,\n  getFileModifiedMap: () => getFileModifiedMap,\n  createContext: () => createContext,\n  getContext: () => getContext\n});\nconst _fs = /*#__PURE__*/_interopRequireDefault(require(\"fs\"));\nconst _url = /*#__PURE__*/_interopRequireDefault(require(\"url\"));\nconst _postcss = /*#__PURE__*/_interopRequireDefault(require(\"postcss\"));\nconst _dlv = /*#__PURE__*/_interopRequireDefault(require(\"dlv\"));\nconst _postcssSelectorParser = /*#__PURE__*/_interopRequireDefault(require(\"postcss-selector-parser\"));\nconst _transformThemeValue = /*#__PURE__*/_interopRequireDefault(require(\"../util/transformThemeValue\"));\nconst _parseObjectStyles = /*#__PURE__*/_interopRequireDefault(require(\"../util/parseObjectStyles\"));\nconst _prefixSelector = /*#__PURE__*/_interopRequireDefault(require(\"../util/prefixSelector\"));\nconst _isPlainObject = /*#__PURE__*/_interopRequireDefault(require(\"../util/isPlainObject\"));\nconst _escapeClassName = /*#__PURE__*/_interopRequireDefault(require(\"../util/escapeClassName\"));\nconst _nameClass = /*#__PURE__*/_interopRequireWildcard(require(\"../util/nameClass\"));\nconst _pluginUtils = require(\"../util/pluginUtils\");\nconst _corePlugins = require(\"../corePlugins\");\nconst _sharedState = /*#__PURE__*/_interopRequireWildcard(require(\"./sharedState\"));\nconst _toPath = require(\"../util/toPath\");\nconst _log = /*#__PURE__*/_interopRequireDefault(require(\"../util/log\"));\nconst _negateValue = /*#__PURE__*/_interopRequireDefault(require(\"../util/negateValue\"));\nconst _isValidArbitraryValue = /*#__PURE__*/_interopRequireDefault(require(\"../util/isValidArbitraryValue\"));\nconst _generateRules = require(\"./generateRules\");\nconst _cacheInvalidationJs = require(\"./cacheInvalidation.js\");\nconst _offsetsJs = require(\"./offsets.js\");\nconst _featureFlagsJs = require(\"../featureFlags.js\");\nconst _formatVariantSelector = require(\"../util/formatVariantSelector\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nconst VARIANT_TYPES = {\n  AddVariant: Symbol.for(\"ADD_VARIANT\"),\n  MatchVariant: Symbol.for(\"MATCH_VARIANT\")\n};\nconst VARIANT_INFO = {\n  Base: 1 << 0,\n  Dynamic: 1 << 1\n};\nfunction prefix(context, selector) {\n  let prefix = context.tailwindConfig.prefix;\n  return typeof prefix === \"function\" ? prefix(selector) : prefix + selector;\n}\nfunction normalizeOptionTypes(_ref) {\n  let {\n    type = \"any\",\n    ...options\n  } = _ref;\n  let types = [].concat(type);\n  return {\n    ...options,\n    types: types.map(type => {\n      if (Array.isArray(type)) {\n        return {\n          type: type[0],\n          ...type[1]\n        };\n      }\n      return {\n        type,\n        preferOnConflict: false\n      };\n    })\n  };\n}\nfunction parseVariantFormatString(input) {\n  if (input.includes(\"{\")) {\n    if (!isBalanced(input)) throw new Error(`Your { and } are unbalanced.`);\n    return input.split(/{(.*)}/gim).flatMap(line => parseVariantFormatString(line)).filter(Boolean);\n  }\n  return [input.trim()];\n}\nfunction isBalanced(input) {\n  let count = 0;\n  for (let char of input) {\n    if (char === \"{\") {\n      count++;\n    } else if (char === \"}\") {\n      if (--count < 0) {\n        return false // unbalanced\n        ;\n      }\n    }\n  }\n\n  return count === 0;\n}\nfunction insertInto(list, value) {\n  let {\n    before = []\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  before = [].concat(before);\n  if (before.length <= 0) {\n    list.push(value);\n    return;\n  }\n  let idx = list.length - 1;\n  for (let other of before) {\n    let iidx = list.indexOf(other);\n    if (iidx === -1) continue;\n    idx = Math.min(idx, iidx);\n  }\n  list.splice(idx, 0, value);\n}\nfunction parseStyles(styles) {\n  if (!Array.isArray(styles)) {\n    return parseStyles([styles]);\n  }\n  return styles.flatMap(style => {\n    let isNode = !Array.isArray(style) && !(0, _isPlainObject.default)(style);\n    return isNode ? style : (0, _parseObjectStyles.default)(style);\n  });\n}\nfunction getClasses(selector, mutate) {\n  let parser = (0, _postcssSelectorParser.default)(selectors => {\n    let allClasses = [];\n    if (mutate) {\n      mutate(selectors);\n    }\n    selectors.walkClasses(classNode => {\n      allClasses.push(classNode.value);\n    });\n    return allClasses;\n  });\n  return parser.transformSync(selector);\n}\nfunction extractCandidates(node) {\n  let state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    containsNonOnDemandable: false\n  };\n  let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let classes = [];\n  // Handle normal rules\n  if (node.type === \"rule\") {\n    // Ignore everything inside a :not(...). This allows you to write code like\n    // `div:not(.foo)`. If `.foo` is never found in your code, then we used to\n    // not generated it. But now we will ignore everything inside a `:not`, so\n    // that it still gets generated.\n    function ignoreNot(selectors) {\n      selectors.walkPseudos(pseudo => {\n        if (pseudo.value === \":not\") {\n          pseudo.remove();\n        }\n      });\n    }\n    for (let selector of node.selectors) {\n      let classCandidates = getClasses(selector, ignoreNot);\n      // At least one of the selectors contains non-\"on-demandable\" candidates.\n      if (classCandidates.length === 0) {\n        state.containsNonOnDemandable = true;\n      }\n      for (let classCandidate of classCandidates) {\n        classes.push(classCandidate);\n      }\n    }\n  } else if (node.type === \"atrule\") {\n    node.walkRules(rule => {\n      for (let classCandidate of rule.selectors.flatMap(selector => getClasses(selector))) {\n        classes.push(classCandidate);\n      }\n    });\n  }\n  if (depth === 0) {\n    return [state.containsNonOnDemandable || classes.length === 0, classes];\n  }\n  return classes;\n}\nfunction withIdentifiers(styles) {\n  return parseStyles(styles).flatMap(node => {\n    let nodeMap = new Map();\n    let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node);\n    // If this isn't \"on-demandable\", assign it a universal candidate to always include it.\n    if (containsNonOnDemandableSelectors) {\n      candidates.unshift(_sharedState.NOT_ON_DEMAND);\n    }\n    // However, it could be that it also contains \"on-demandable\" candidates.\n    // E.g.: `span, .foo {}`, in that case it should still be possible to use\n    // `@apply foo` for example.\n    return candidates.map(c => {\n      if (!nodeMap.has(node)) {\n        nodeMap.set(node, node);\n      }\n      return [c, nodeMap.get(node)];\n    });\n  });\n}\nfunction isValidVariantFormatString(format) {\n  return format.startsWith(\"@\") || format.includes(\"&\");\n}\nfunction parseVariant(variant) {\n  variant = variant.replace(/\\n+/g, \"\").replace(/\\s{1,}/g, \" \").trim();\n  let fns = parseVariantFormatString(variant).map(str => {\n    if (!str.startsWith(\"@\")) {\n      return _ref2 => {\n        let {\n          format\n        } = _ref2;\n        return format(str);\n      };\n    }\n    let [, name, params] = /@(.*?)( .+|[({].*)/g.exec(str);\n    return _ref3 => {\n      let {\n        wrap\n      } = _ref3;\n      return wrap(_postcss.default.atRule({\n        name,\n        params: params.trim()\n      }));\n    };\n  }).reverse();\n  return api => {\n    for (let fn of fns) {\n      fn(api);\n    }\n  };\n}\n/**\n *\n * @param {any} tailwindConfig\n * @param {any} context\n * @param {object} param2\n * @param {Offsets} param2.offsets\n */\nfunction buildPluginApi(tailwindConfig, context, _ref4) {\n  let {\n    variantList,\n    variantMap,\n    offsets,\n    classList\n  } = _ref4;\n  function getConfigValue(path, defaultValue) {\n    return path ? (0, _dlv.default)(tailwindConfig, path, defaultValue) : tailwindConfig;\n  }\n  function applyConfiguredPrefix(selector) {\n    return (0, _prefixSelector.default)(tailwindConfig.prefix, selector);\n  }\n  function prefixIdentifier(identifier, options) {\n    if (identifier === _sharedState.NOT_ON_DEMAND) {\n      return _sharedState.NOT_ON_DEMAND;\n    }\n    if (!options.respectPrefix) {\n      return identifier;\n    }\n    return context.tailwindConfig.prefix + identifier;\n  }\n  function resolveThemeValue(path, defaultValue) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const [pathRoot, ...subPaths] = (0, _toPath.toPath)(path);\n    const value = getConfigValue([\"theme\", pathRoot, ...subPaths], defaultValue);\n    return (0, _transformThemeValue.default)(pathRoot)(value, opts);\n  }\n  const theme = Object.assign(function (path) {\n    let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    return resolveThemeValue(path, defaultValue);\n  }, {\n    withAlpha: (path, opacityValue) => resolveThemeValue(path, undefined, {\n      opacityValue\n    })\n  });\n  let variantIdentifier = 0;\n  let api = {\n    postcss: _postcss.default,\n    prefix: applyConfiguredPrefix,\n    e: _escapeClassName.default,\n    config: getConfigValue,\n    theme,\n    corePlugins: path => {\n      if (Array.isArray(tailwindConfig.corePlugins)) {\n        return tailwindConfig.corePlugins.includes(path);\n      }\n      return getConfigValue([\"corePlugins\", path], true);\n    },\n    variants: () => {\n      // Preserved for backwards compatibility but not used in v3.0+\n      return [];\n    },\n    addBase(base) {\n      for (let [identifier, rule] of withIdentifiers(base)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, {});\n        let offset = offsets.create(\"base\");\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offset,\n          layer: \"base\"\n        }, rule]);\n      }\n    },\n    /**\n    * @param {string} group\n    * @param {Record<string, string | string[]>} declarations\n    */\n    addDefaults(group, declarations) {\n      const groups = {\n        [`@defaults ${group}`]: declarations\n      };\n      for (let [identifier, rule] of withIdentifiers(groups)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, {});\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offsets.create(\"defaults\"),\n          layer: \"defaults\"\n        }, rule]);\n      }\n    },\n    addComponents(components, options) {\n      let defaultOptions = {\n        preserveSource: false,\n        respectPrefix: true,\n        respectImportant: false\n      };\n      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n      for (let [identifier, rule] of withIdentifiers(components)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        classList.add(prefixedIdentifier);\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offsets.create(\"components\"),\n          layer: \"components\",\n          options\n        }, rule]);\n      }\n    },\n    addUtilities(utilities, options) {\n      let defaultOptions = {\n        preserveSource: false,\n        respectPrefix: true,\n        respectImportant: true\n      };\n      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n      for (let [identifier, rule] of withIdentifiers(utilities)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        classList.add(prefixedIdentifier);\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offsets.create(\"utilities\"),\n          layer: \"utilities\",\n          options\n        }, rule]);\n      }\n    },\n    matchUtilities: function (utilities, options) {\n      let defaultOptions = {\n        respectPrefix: true,\n        respectImportant: true,\n        modifiers: false\n      };\n      options = normalizeOptionTypes({\n        ...defaultOptions,\n        ...options\n      });\n      let offset = offsets.create(\"utilities\");\n      for (let identifier in utilities) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        let rule = utilities[identifier];\n        classList.add([prefixedIdentifier, options]);\n        function wrapped(modifier, _ref5) {\n          let {\n            isOnlyPlugin\n          } = _ref5;\n          let [value, coercedType, utilityModifier] = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig);\n          if (value === undefined) {\n            return [];\n          }\n          if (!options.types.some(_ref6 => {\n            let {\n              type\n            } = _ref6;\n            return type === coercedType;\n          })) {\n            if (isOnlyPlugin) {\n              _log.default.warn([`Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`, `You can safely update it to \\`${identifier}-${modifier.replace(coercedType + \":\", \"\")}\\`.`]);\n            } else {\n              return [];\n            }\n          }\n          if (!(0, _isValidArbitraryValue.default)(value)) {\n            return [];\n          }\n          let extras = {\n            get modifier() {\n              if (!options.modifiers) {\n                _log.default.warn(`modifier-used-without-options-for-${identifier}`, [\"Your plugin must set `modifiers: true` in its options to support modifiers.\"]);\n              }\n              return utilityModifier;\n            }\n          };\n          let modifiersEnabled = (0, _featureFlagsJs.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n          let ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map(declaration => ({\n            [(0, _nameClass.default)(identifier, modifier)]: declaration\n          }));\n          return ruleSets;\n        }\n        let withOffsets = [{\n          sort: offset,\n          layer: \"utilities\",\n          options\n        }, wrapped];\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n      }\n    },\n    matchComponents: function (components, options) {\n      let defaultOptions = {\n        respectPrefix: true,\n        respectImportant: false,\n        modifiers: false\n      };\n      options = normalizeOptionTypes({\n        ...defaultOptions,\n        ...options\n      });\n      let offset = offsets.create(\"components\");\n      for (let identifier in components) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        let rule = components[identifier];\n        classList.add([prefixedIdentifier, options]);\n        function wrapped(modifier, _ref7) {\n          let {\n            isOnlyPlugin\n          } = _ref7;\n          let [value, coercedType, utilityModifier] = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig);\n          if (value === undefined) {\n            return [];\n          }\n          if (!options.types.some(_ref8 => {\n            let {\n              type\n            } = _ref8;\n            return type === coercedType;\n          })) {\n            if (isOnlyPlugin) {\n              _log.default.warn([`Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`, `You can safely update it to \\`${identifier}-${modifier.replace(coercedType + \":\", \"\")}\\`.`]);\n            } else {\n              return [];\n            }\n          }\n          if (!(0, _isValidArbitraryValue.default)(value)) {\n            return [];\n          }\n          let extras = {\n            get modifier() {\n              if (!options.modifiers) {\n                _log.default.warn(`modifier-used-without-options-for-${identifier}`, [\"Your plugin must set `modifiers: true` in its options to support modifiers.\"]);\n              }\n              return utilityModifier;\n            }\n          };\n          let modifiersEnabled = (0, _featureFlagsJs.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n          let ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map(declaration => ({\n            [(0, _nameClass.default)(identifier, modifier)]: declaration\n          }));\n          return ruleSets;\n        }\n        let withOffsets = [{\n          sort: offset,\n          layer: \"components\",\n          options\n        }, wrapped];\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n      }\n    },\n    addVariant(variantName, variantFunctions) {\n      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      variantFunctions = [].concat(variantFunctions).map(variantFunction => {\n        if (typeof variantFunction !== \"string\") {\n          // Safelist public API functions\n          return function () {\n            let api = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            let {\n              args,\n              modifySelectors,\n              container,\n              separator,\n              wrap,\n              format\n            } = api;\n            let result = variantFunction(Object.assign({\n              modifySelectors,\n              container,\n              separator\n            }, options.type === VARIANT_TYPES.MatchVariant && {\n              args,\n              wrap,\n              format\n            }));\n            if (typeof result === \"string\" && !isValidVariantFormatString(result)) {\n              throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n            }\n            if (Array.isArray(result)) {\n              return result.filter(variant => typeof variant === \"string\").map(variant => parseVariant(variant));\n            }\n            // result may be undefined with legacy variants that use APIs like `modifySelectors`\n            // result may also be a postcss node if someone was returning the result from `modifySelectors`\n            return result && typeof result === \"string\" && parseVariant(result)(api);\n          };\n        }\n        if (!isValidVariantFormatString(variantFunction)) {\n          throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n        }\n        return parseVariant(variantFunction);\n      });\n      insertInto(variantList, variantName, options);\n      variantMap.set(variantName, variantFunctions);\n      context.variantOptions.set(variantName, options);\n    },\n    matchVariant(variant, variantFn, options) {\n      var ref;\n      // A unique identifier that \"groups\" these variants together.\n      // This is for internal use only which is why it is not present in the types\n      let id = (ref = options === null || options === void 0 ? void 0 : options.id) !== null && ref !== void 0 ? ref : ++variantIdentifier;\n      let isSpecial = variant === \"@\";\n      let modifiersEnabled = (0, _featureFlagsJs.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n      var ref1;\n      for (let [key, value] of Object.entries((ref1 = options === null || options === void 0 ? void 0 : options.values) !== null && ref1 !== void 0 ? ref1 : {})) {\n        if (key === \"DEFAULT\") continue;\n        api.addVariant(isSpecial ? `${variant}${key}` : `${variant}-${key}`, _ref9 => {\n          let {\n            args,\n            container\n          } = _ref9;\n          return variantFn(value, modifiersEnabled ? {\n            modifier: args === null || args === void 0 ? void 0 : args.modifier,\n            container\n          } : {\n            container\n          });\n        }, {\n          ...options,\n          value,\n          id,\n          type: VARIANT_TYPES.MatchVariant,\n          variantInfo: VARIANT_INFO.Base\n        });\n      }\n      var ref2;\n      let hasDefault = (\"DEFAULT\" in ((ref2 = options === null || options === void 0 ? void 0 : options.values) !== null && ref2 !== void 0 ? ref2 : {}));\n      api.addVariant(variant, _ref10 => {\n        let {\n          args,\n          container\n        } = _ref10;\n        if ((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE && !hasDefault) {\n          return null;\n        }\n        var\n        // (JetBrains) plugins.\n        ref;\n        return variantFn((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE ? options.values.DEFAULT : (ref = args === null || args === void 0 ? void 0 : args.value) !== null && ref !== void 0 ? ref : typeof args === \"string\" ? args : \"\", modifiersEnabled ? {\n          modifier: args === null || args === void 0 ? void 0 : args.modifier,\n          container\n        } : {\n          container\n        });\n      }, {\n        ...options,\n        id,\n        type: VARIANT_TYPES.MatchVariant,\n        variantInfo: VARIANT_INFO.Dynamic\n      });\n    }\n  };\n  return api;\n}\nlet fileModifiedMapCache = new WeakMap();\nfunction getFileModifiedMap(context) {\n  if (!fileModifiedMapCache.has(context)) {\n    fileModifiedMapCache.set(context, new Map());\n  }\n  return fileModifiedMapCache.get(context);\n}\nfunction trackModified(files, fileModifiedMap) {\n  let changed = false;\n  for (let file of files) {\n    var ref;\n    if (!file) continue;\n    let parsed = _url.default.parse(file);\n    let pathname = parsed.hash ? parsed.href.replace(parsed.hash, \"\") : parsed.href;\n    pathname = parsed.search ? pathname.replace(parsed.search, \"\") : pathname;\n    let newModified = (ref = _fs.default.statSync(decodeURIComponent(pathname), {\n      throwIfNoEntry: false\n    })) === null || ref === void 0 ? void 0 : ref.mtimeMs;\n    if (!newModified) {\n      continue;\n    }\n    if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) {\n      changed = true;\n    }\n    fileModifiedMap.set(file, newModified);\n  }\n  return changed;\n}\nfunction extractVariantAtRules(node) {\n  node.walkAtRules(atRule => {\n    if ([\"responsive\", \"variants\"].includes(atRule.name)) {\n      extractVariantAtRules(atRule);\n      atRule.before(atRule.nodes);\n      atRule.remove();\n    }\n  });\n}\nfunction collectLayerPlugins(root) {\n  let layerPlugins = [];\n  root.each(node => {\n    if (node.type === \"atrule\" && [\"responsive\", \"variants\"].includes(node.name)) {\n      node.name = \"layer\";\n      node.params = \"utilities\";\n    }\n  });\n  // Walk @layer rules and treat them like plugins\n  root.walkAtRules(\"layer\", layerRule => {\n    extractVariantAtRules(layerRule);\n    if (layerRule.params === \"base\") {\n      for (let node of layerRule.nodes) {\n        layerPlugins.push(function (_ref11) {\n          let {\n            addBase\n          } = _ref11;\n          addBase(node, {\n            respectPrefix: false\n          });\n        });\n      }\n      layerRule.remove();\n    } else if (layerRule.params === \"components\") {\n      for (let node1 of layerRule.nodes) {\n        layerPlugins.push(function (_ref12) {\n          let {\n            addComponents\n          } = _ref12;\n          addComponents(node1, {\n            respectPrefix: false,\n            preserveSource: true\n          });\n        });\n      }\n      layerRule.remove();\n    } else if (layerRule.params === \"utilities\") {\n      for (let node2 of layerRule.nodes) {\n        layerPlugins.push(function (_ref13) {\n          let {\n            addUtilities\n          } = _ref13;\n          addUtilities(node2, {\n            respectPrefix: false,\n            preserveSource: true\n          });\n        });\n      }\n      layerRule.remove();\n    }\n  });\n  return layerPlugins;\n}\nfunction resolvePlugins(context, root) {\n  let corePluginList = Object.entries({\n    ..._corePlugins.variantPlugins,\n    ..._corePlugins.corePlugins\n  }).map(_ref14 => {\n    let [name, plugin] = _ref14;\n    if (!context.tailwindConfig.corePlugins.includes(name)) {\n      return null;\n    }\n    return plugin;\n  }).filter(Boolean);\n  let userPlugins = context.tailwindConfig.plugins.map(plugin => {\n    if (plugin.__isOptionsFunction) {\n      plugin = plugin();\n    }\n    return typeof plugin === \"function\" ? plugin : plugin.handler;\n  });\n  let layerPlugins = collectLayerPlugins(root);\n  // TODO: This is a workaround for backwards compatibility, since custom variants\n  // were historically sorted before screen/stackable variants.\n  let beforeVariants = [_corePlugins.variantPlugins[\"pseudoElementVariants\"], _corePlugins.variantPlugins[\"pseudoClassVariants\"], _corePlugins.variantPlugins[\"ariaVariants\"], _corePlugins.variantPlugins[\"dataVariants\"]];\n  let afterVariants = [_corePlugins.variantPlugins[\"supportsVariants\"], _corePlugins.variantPlugins[\"directionVariants\"], _corePlugins.variantPlugins[\"reducedMotionVariants\"], _corePlugins.variantPlugins[\"prefersContrastVariants\"], _corePlugins.variantPlugins[\"darkVariants\"], _corePlugins.variantPlugins[\"printVariant\"], _corePlugins.variantPlugins[\"screenVariants\"], _corePlugins.variantPlugins[\"orientationVariants\"]];\n  return [...corePluginList, ...beforeVariants, ...userPlugins, ...afterVariants, ...layerPlugins];\n}\nfunction registerPlugins(plugins, context) {\n  let variantList = [];\n  let variantMap = new Map();\n  context.variantMap = variantMap;\n  let offsets = new _offsetsJs.Offsets();\n  context.offsets = offsets;\n  let classList = new Set();\n  let pluginApi = buildPluginApi(context.tailwindConfig, context, {\n    variantList,\n    variantMap,\n    offsets,\n    classList\n  });\n  for (let plugin of plugins) {\n    if (Array.isArray(plugin)) {\n      for (let pluginItem of plugin) {\n        pluginItem(pluginApi);\n      }\n    } else {\n      plugin === null || plugin === void 0 ? void 0 : plugin(pluginApi);\n    }\n  }\n  // Make sure to record bit masks for every variant\n  offsets.recordVariants(variantList, variant => variantMap.get(variant).length);\n  // Build variantMap\n  for (let [variantName, variantFunctions] of variantMap.entries()) {\n    context.variantMap.set(variantName, variantFunctions.map((variantFunction, idx) => [offsets.forVariant(variantName, idx), variantFunction]));\n  }\n  var _safelist;\n  let safelist = ((_safelist = context.tailwindConfig.safelist) !== null && _safelist !== void 0 ? _safelist : []).filter(Boolean);\n  if (safelist.length > 0) {\n    let checks = [];\n    for (let value of safelist) {\n      if (typeof value === \"string\") {\n        context.changedContent.push({\n          content: value,\n          extension: \"html\"\n        });\n        continue;\n      }\n      if (value instanceof RegExp) {\n        _log.default.warn(\"root-regex\", [\"Regular expressions in `safelist` work differently in Tailwind CSS v3.0.\", \"Update your `safelist` configuration to eliminate this warning.\", \"https://tailwindcss.com/docs/content-configuration#safelisting-classes\"]);\n        continue;\n      }\n      checks.push(value);\n    }\n    if (checks.length > 0) {\n      let patternMatchingCount = new Map();\n      let prefixLength = context.tailwindConfig.prefix.length;\n      let checkImportantUtils = checks.some(check => check.pattern.source.includes(\"!\"));\n      for (let util of classList) {\n        let utils = Array.isArray(util) ? (() => {\n          let [utilName, options] = util;\n          var ref;\n          let values = Object.keys((ref = options === null || options === void 0 ? void 0 : options.values) !== null && ref !== void 0 ? ref : {});\n          let classes = values.map(value => (0, _nameClass.formatClass)(utilName, value));\n          if (options === null || options === void 0 ? void 0 : options.supportsNegativeValues) {\n            // This is the normal negated version\n            // e.g. `-inset-1` or `-tw-inset-1`\n            classes = [...classes, ...classes.map(cls => \"-\" + cls)];\n            // This is the negated version *after* the prefix\n            // e.g. `tw--inset-1`\n            // The prefix is already attached to util name\n            // So we add the negative after the prefix\n            classes = [...classes, ...classes.map(cls => cls.slice(0, prefixLength) + \"-\" + cls.slice(prefixLength))];\n          }\n          if (options.types.some(_ref15 => {\n            let {\n              type\n            } = _ref15;\n            return type === \"color\";\n          })) {\n            classes = [...classes, ...classes.flatMap(cls => Object.keys(context.tailwindConfig.theme.opacity).map(opacity => `${cls}/${opacity}`))];\n          }\n          if (checkImportantUtils && (options === null || options === void 0 ? void 0 : options.respectImportant)) {\n            classes = [...classes, ...classes.map(cls => \"!\" + cls)];\n          }\n          return classes;\n        })() : [util];\n        for (let util1 of utils) {\n          for (let {\n            pattern,\n            variants = []\n          } of checks) {\n            // RegExp with the /g flag are stateful, so let's reset the last\n            // index pointer to reset the state.\n            pattern.lastIndex = 0;\n            if (!patternMatchingCount.has(pattern)) {\n              patternMatchingCount.set(pattern, 0);\n            }\n            if (!pattern.test(util1)) continue;\n            patternMatchingCount.set(pattern, patternMatchingCount.get(pattern) + 1);\n            context.changedContent.push({\n              content: util1,\n              extension: \"html\"\n            });\n            for (let variant of variants) {\n              context.changedContent.push({\n                content: variant + context.tailwindConfig.separator + util1,\n                extension: \"html\"\n              });\n            }\n          }\n        }\n      }\n      for (let [regex, count] of patternMatchingCount.entries()) {\n        if (count !== 0) continue;\n        _log.default.warn([`The safelist pattern \\`${regex}\\` doesn't match any Tailwind CSS classes.`, \"Fix this pattern or remove it from your `safelist` configuration.\", \"https://tailwindcss.com/docs/content-configuration#safelisting-classes\"]);\n      }\n    }\n  }\n  var _darkMode, ref;\n  let darkClassName = (ref = [].concat((_darkMode = context.tailwindConfig.darkMode) !== null && _darkMode !== void 0 ? _darkMode : \"media\")[1]) !== null && ref !== void 0 ? ref : \"dark\";\n  // A list of utilities that are used by certain Tailwind CSS utilities but\n  // that don't exist on their own. This will result in them \"not existing\" and\n  // sorting could be weird since you still require them in order to make the\n  // host utilities work properly. (Thanks Biology)\n  let parasiteUtilities = [prefix(context, darkClassName), prefix(context, \"group\"), prefix(context, \"peer\")];\n  context.getClassOrder = function getClassOrder(classes) {\n    // Non-util classes won't be generated, so we default them to null\n    let sortedClassNames = new Map(classes.map(className => [className, null]));\n    // Sort all classes in order\n    // Non-tailwind classes won't be generated and will be left as `null`\n    let rules = (0, _generateRules.generateRules)(new Set(classes), context);\n    rules = context.offsets.sort(rules);\n    let idx = BigInt(parasiteUtilities.length);\n    for (const [, rule] of rules) {\n      sortedClassNames.set(rule.raws.tailwind.candidate, idx++);\n    }\n    return classes.map(className => {\n      var ref;\n      let order = (ref = sortedClassNames.get(className)) !== null && ref !== void 0 ? ref : null;\n      let parasiteIndex = parasiteUtilities.indexOf(className);\n      if (order === null && parasiteIndex !== -1) {\n        // This will make sure that it is at the very beginning of the\n        // `components` layer which technically means 'before any\n        // components'.\n        order = BigInt(parasiteIndex);\n      }\n      return [className, order];\n    });\n  };\n  // Generate a list of strings for autocompletion purposes, e.g.\n  // ['uppercase', 'lowercase', ...]\n  context.getClassList = function getClassList() {\n    let output = [];\n    for (let util of classList) {\n      if (Array.isArray(util)) {\n        let [utilName, options] = util;\n        let negativeClasses = [];\n        var ref;\n        for (let [key, value] of Object.entries((ref = options === null || options === void 0 ? void 0 : options.values) !== null && ref !== void 0 ? ref : {})) {\n          // Ignore undefined and null values\n          if (value == null) {\n            continue;\n          }\n          output.push((0, _nameClass.formatClass)(utilName, key));\n          if ((options === null || options === void 0 ? void 0 : options.supportsNegativeValues) && (0, _negateValue.default)(value)) {\n            negativeClasses.push((0, _nameClass.formatClass)(utilName, `-${key}`));\n          }\n        }\n        output.push(...negativeClasses);\n      } else {\n        output.push(util);\n      }\n    }\n    return output;\n  };\n  // Generate a list of available variants with meta information of the type of variant.\n  context.getVariants = function getVariants() {\n    let result = [];\n    for (let [name, options] of context.variantOptions.entries()) {\n      if (options.variantInfo === VARIANT_INFO.Base) continue;\n      var _values;\n      result.push({\n        name,\n        isArbitrary: options.type === Symbol.for(\"MATCH_VARIANT\"),\n        values: Object.keys((_values = options.values) !== null && _values !== void 0 ? _values : {}),\n        hasDash: name !== \"@\",\n        selectors() {\n          let {\n            modifier,\n            value\n          } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          let candidate = \"__TAILWIND_PLACEHOLDER__\";\n          let rule = _postcss.default.rule({\n            selector: `.${candidate}`\n          });\n          let container = _postcss.default.root({\n            nodes: [rule.clone()]\n          });\n          let before = container.toString();\n          var ref;\n          let fns = ((ref = context.variantMap.get(name)) !== null && ref !== void 0 ? ref : []).flatMap(_ref16 => {\n            let [_, fn] = _ref16;\n            return fn;\n          });\n          let formatStrings = [];\n          for (let fn of fns) {\n            var ref1;\n            let localFormatStrings = [];\n            var ref2;\n            let api = {\n              args: {\n                modifier,\n                value: (ref2 = (ref1 = options.values) === null || ref1 === void 0 ? void 0 : ref1[value]) !== null && ref2 !== void 0 ? ref2 : value\n              },\n              separator: context.tailwindConfig.separator,\n              modifySelectors(modifierFunction) {\n                // Run the modifierFunction over each rule\n                container.each(rule => {\n                  if (rule.type !== \"rule\") {\n                    return;\n                  }\n                  rule.selectors = rule.selectors.map(selector => {\n                    return modifierFunction({\n                      get className() {\n                        return (0, _generateRules.getClassNameFromSelector)(selector);\n                      },\n                      selector\n                    });\n                  });\n                });\n                return container;\n              },\n              format(str) {\n                localFormatStrings.push(str);\n              },\n              wrap(wrapper) {\n                localFormatStrings.push(`@${wrapper.name} ${wrapper.params} { & }`);\n              },\n              container\n            };\n            let ruleWithVariant = fn(api);\n            if (localFormatStrings.length > 0) {\n              formatStrings.push(localFormatStrings);\n            }\n            if (Array.isArray(ruleWithVariant)) {\n              for (let variantFunction of ruleWithVariant) {\n                localFormatStrings = [];\n                variantFunction(api);\n                formatStrings.push(localFormatStrings);\n              }\n            }\n          }\n          // Reverse engineer the result of the `container`\n          let manualFormatStrings = [];\n          let after = container.toString();\n          if (before !== after) {\n            // Figure out all selectors\n            container.walkRules(rule => {\n              let modified = rule.selector;\n              // Rebuild the base selector, this is what plugin authors would do\n              // as well. E.g.: `${variant}${separator}${className}`.\n              // However, plugin authors probably also prepend or append certain\n              // classes, pseudos, ids, ...\n              let rebuiltBase = (0, _postcssSelectorParser.default)(selectors => {\n                selectors.walkClasses(classNode => {\n                  classNode.value = `${name}${context.tailwindConfig.separator}${classNode.value}`;\n                });\n              }).processSync(modified);\n              // Now that we know the original selector, the new selector, and\n              // the rebuild part in between, we can replace the part that plugin\n              // authors need to rebuild with `&`, and eventually store it in the\n              // collectedFormats. Similar to what `format('...')` would do.\n              //\n              // E.g.:\n              //                   variant: foo\n              //                  selector: .markdown > p\n              //      modified (by plugin): .foo .foo\\\\:markdown > p\n              //    rebuiltBase (internal): .foo\\\\:markdown > p\n              //                    format: .foo &\n              manualFormatStrings.push(modified.replace(rebuiltBase, \"&\").replace(candidate, \"&\"));\n            });\n            // Figure out all atrules\n            container.walkAtRules(atrule => {\n              manualFormatStrings.push(`@${atrule.name} (${atrule.params}) { & }`);\n            });\n          }\n          var _values;\n          let result = formatStrings.map(formatString => (0, _formatVariantSelector.finalizeSelector)((0, _formatVariantSelector.formatVariantSelector)(\"&\", ...formatString), {\n            selector: `.${candidate}`,\n            candidate,\n            context,\n            isArbitraryVariant: !(value in ((_values = options.values) !== null && _values !== void 0 ? _values : {}))\n          }).replace(`.${candidate}`, \"&\").replace(\"{ & }\", \"\").trim());\n          if (manualFormatStrings.length > 0) {\n            result.push((0, _formatVariantSelector.formatVariantSelector)(\"&\", ...manualFormatStrings));\n          }\n          return result;\n        }\n      });\n    }\n    return result;\n  };\n}\n/**\n * Mark as class as retroactively invalid\n *\n *\n * @param {string} candidate\n */\nfunction markInvalidUtilityCandidate(context, candidate) {\n  if (!context.classCache.has(candidate)) {\n    return;\n  }\n  // Mark this as not being a real utility\n  context.notClassCache.add(candidate);\n  // Remove it from any candidate-specific caches\n  context.classCache.delete(candidate);\n  context.applyClassCache.delete(candidate);\n  context.candidateRuleMap.delete(candidate);\n  context.candidateRuleCache.delete(candidate);\n  // Ensure the stylesheet gets rebuilt\n  context.stylesheetCache = null;\n}\n/**\n * Mark as class as retroactively invalid\n *\n * @param {import('postcss').Node} node\n */\nfunction markInvalidUtilityNode(context, node) {\n  let candidate = node.raws.tailwind.candidate;\n  if (!candidate) {\n    return;\n  }\n  for (const entry of context.ruleCache) {\n    if (entry[1].raws.tailwind.candidate === candidate) {\n      context.ruleCache.delete(entry);\n      // context.postCssNodeCache.delete(node)\n    }\n  }\n\n  markInvalidUtilityCandidate(context, candidate);\n}\nfunction createContext(tailwindConfig) {\n  let changedContent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let root = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _postcss.default.root();\n  var _blocklist;\n  let context = {\n    disposables: [],\n    ruleCache: new Set(),\n    candidateRuleCache: new Map(),\n    classCache: new Map(),\n    applyClassCache: new Map(),\n    // Seed the not class cache with the blocklist (which is only strings)\n    notClassCache: new Set((_blocklist = tailwindConfig.blocklist) !== null && _blocklist !== void 0 ? _blocklist : []),\n    postCssNodeCache: new Map(),\n    candidateRuleMap: new Map(),\n    tailwindConfig,\n    changedContent: changedContent,\n    variantMap: new Map(),\n    stylesheetCache: null,\n    variantOptions: new Map(),\n    markInvalidUtilityCandidate: candidate => markInvalidUtilityCandidate(context, candidate),\n    markInvalidUtilityNode: node => markInvalidUtilityNode(context, node)\n  };\n  let resolvedPlugins = resolvePlugins(context, root);\n  registerPlugins(resolvedPlugins, context);\n  return context;\n}\nlet contextMap = _sharedState.contextMap;\nlet configContextMap = _sharedState.configContextMap;\nlet contextSourcesMap = _sharedState.contextSourcesMap;\nfunction getContext(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies) {\n  let sourcePath = result.opts.from;\n  let isConfigFile = userConfigPath !== null;\n  _sharedState.env.DEBUG && console.log(\"Source path:\", sourcePath);\n  let existingContext;\n  if (isConfigFile && contextMap.has(sourcePath)) {\n    existingContext = contextMap.get(sourcePath);\n  } else if (configContextMap.has(tailwindConfigHash)) {\n    let context = configContextMap.get(tailwindConfigHash);\n    contextSourcesMap.get(context).add(sourcePath);\n    contextMap.set(sourcePath, context);\n    existingContext = context;\n  }\n  let cssDidChange = (0, _cacheInvalidationJs.hasContentChanged)(sourcePath, root);\n  // If there's already a context in the cache and we don't need to\n  // reset the context, return the cached context.\n  if (existingContext) {\n    let contextDependenciesChanged = trackModified([...contextDependencies], getFileModifiedMap(existingContext));\n    if (!contextDependenciesChanged && !cssDidChange) {\n      return [existingContext, false];\n    }\n  }\n  // If this source is in the context map, get the old context.\n  // Remove this source from the context sources for the old context,\n  // and clean up that context if no one else is using it. This can be\n  // called by many processes in rapid succession, so we check for presence\n  // first because the first process to run this code will wipe it out first.\n  if (contextMap.has(sourcePath)) {\n    let oldContext = contextMap.get(sourcePath);\n    if (contextSourcesMap.has(oldContext)) {\n      contextSourcesMap.get(oldContext).delete(sourcePath);\n      if (contextSourcesMap.get(oldContext).size === 0) {\n        contextSourcesMap.delete(oldContext);\n        for (let [tailwindConfigHash1, context1] of configContextMap) {\n          if (context1 === oldContext) {\n            configContextMap.delete(tailwindConfigHash1);\n          }\n        }\n        for (let disposable of oldContext.disposables.splice(0)) {\n          disposable(oldContext);\n        }\n      }\n    }\n  }\n  _sharedState.env.DEBUG && console.log(\"Setting up new context...\");\n  let context2 = createContext(tailwindConfig, [], root);\n  Object.assign(context2, {\n    userConfigPath\n  });\n  trackModified([...contextDependencies], getFileModifiedMap(context2));\n  // ---\n  // Update all context tracking state\n  configContextMap.set(tailwindConfigHash, context2);\n  contextMap.set(sourcePath, context2);\n  if (!contextSourcesMap.has(context2)) {\n    contextSourcesMap.set(context2, new Set());\n  }\n  contextSourcesMap.get(context2).add(sourcePath);\n  return [context2, true];\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_export","target","all","name","enumerable","get","isValidVariantFormatString","parseVariant","getFileModifiedMap","createContext","getContext","_fs","_interopRequireDefault","require","_url","_postcss","_dlv","_postcssSelectorParser","_transformThemeValue","_parseObjectStyles","_prefixSelector","_isPlainObject","_escapeClassName","_nameClass","_interopRequireWildcard","_pluginUtils","_corePlugins","_sharedState","_toPath","_log","_negateValue","_isValidArbitraryValue","_generateRules","_cacheInvalidationJs","_offsetsJs","_featureFlagsJs","_formatVariantSelector","obj","__esModule","default","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","VARIANT_TYPES","AddVariant","Symbol","for","MatchVariant","VARIANT_INFO","Base","Dynamic","prefix","context","selector","tailwindConfig","normalizeOptionTypes","type","options","types","concat","map","Array","isArray","preferOnConflict","parseVariantFormatString","input","includes","isBalanced","Error","split","flatMap","line","filter","Boolean","trim","count","char","insertInto","list","before","length","push","idx","other","iidx","indexOf","Math","min","splice","parseStyles","styles","style","isNode","getClasses","mutate","parser","selectors","allClasses","walkClasses","classNode","transformSync","extractCandidates","node","state","containsNonOnDemandable","depth","classes","ignoreNot","walkPseudos","pseudo","remove","classCandidates","classCandidate","walkRules","rule","withIdentifiers","nodeMap","Map","containsNonOnDemandableSelectors","candidates","unshift","NOT_ON_DEMAND","c","format","startsWith","variant","replace","fns","str","params","exec","wrap","atRule","reverse","api","fn","buildPluginApi","variantList","variantMap","offsets","classList","getConfigValue","path","defaultValue","applyConfiguredPrefix","prefixIdentifier","identifier","respectPrefix","resolveThemeValue","opts","pathRoot","subPaths","toPath","theme","assign","undefined","withAlpha","opacityValue","variantIdentifier","postcss","e","config","corePlugins","variants","addBase","base","prefixedIdentifier","offset","create","candidateRuleMap","sort","layer","addDefaults","group","declarations","groups","addComponents","components","defaultOptions","preserveSource","respectImportant","add","addUtilities","utilities","matchUtilities","modifiers","wrapped","modifier","isOnlyPlugin","coercedType","utilityModifier","coerceValue","some","warn","extras","modifiersEnabled","flagEnabled","ruleSets","declaration","withOffsets","matchComponents","addVariant","variantName","variantFunctions","variantFunction","args","modifySelectors","container","separator","result","variantOptions","matchVariant","variantFn","ref","id","isSpecial","ref1","entries","values","variantInfo","ref2","hasDefault","NONE","DEFAULT","fileModifiedMapCache","trackModified","files","fileModifiedMap","changed","file","parsed","parse","pathname","hash","href","search","newModified","statSync","decodeURIComponent","throwIfNoEntry","mtimeMs","extractVariantAtRules","walkAtRules","nodes","collectLayerPlugins","root","layerPlugins","each","layerRule","node1","node2","resolvePlugins","corePluginList","variantPlugins","plugin","userPlugins","plugins","__isOptionsFunction","handler","beforeVariants","afterVariants","registerPlugins","Offsets","Set","pluginApi","pluginItem","recordVariants","forVariant","_safelist","safelist","checks","changedContent","content","extension","RegExp","patternMatchingCount","prefixLength","checkImportantUtils","check","pattern","source","util","utils","utilName","keys","formatClass","supportsNegativeValues","cls","slice","opacity","util1","lastIndex","test","regex","_darkMode","darkClassName","darkMode","parasiteUtilities","getClassOrder","sortedClassNames","className","rules","generateRules","BigInt","raws","tailwind","candidate","order","parasiteIndex","getClassList","output","negativeClasses","getVariants","_values","isArbitrary","hasDash","clone","toString","_","formatStrings","localFormatStrings","modifierFunction","getClassNameFromSelector","wrapper","ruleWithVariant","manualFormatStrings","after","modified","rebuiltBase","processSync","atrule","formatString","finalizeSelector","formatVariantSelector","isArbitraryVariant","markInvalidUtilityCandidate","classCache","notClassCache","delete","applyClassCache","candidateRuleCache","stylesheetCache","markInvalidUtilityNode","entry","ruleCache","_blocklist","disposables","blocklist","postCssNodeCache","resolvedPlugins","contextMap","configContextMap","contextSourcesMap","userConfigPath","tailwindConfigHash","contextDependencies","sourcePath","from","isConfigFile","env","DEBUG","console","log","existingContext","cssDidChange","hasContentChanged","contextDependenciesChanged","oldContext","size","tailwindConfigHash1","context1","disposable","context2"],"sources":["/home/sahithya/bios/login/fronte/node_modules/tailwindcss/lib/lib/setupContextUtils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    isValidVariantFormatString: ()=>isValidVariantFormatString,\n    parseVariant: ()=>parseVariant,\n    getFileModifiedMap: ()=>getFileModifiedMap,\n    createContext: ()=>createContext,\n    getContext: ()=>getContext\n});\nconst _fs = /*#__PURE__*/ _interopRequireDefault(require(\"fs\"));\nconst _url = /*#__PURE__*/ _interopRequireDefault(require(\"url\"));\nconst _postcss = /*#__PURE__*/ _interopRequireDefault(require(\"postcss\"));\nconst _dlv = /*#__PURE__*/ _interopRequireDefault(require(\"dlv\"));\nconst _postcssSelectorParser = /*#__PURE__*/ _interopRequireDefault(require(\"postcss-selector-parser\"));\nconst _transformThemeValue = /*#__PURE__*/ _interopRequireDefault(require(\"../util/transformThemeValue\"));\nconst _parseObjectStyles = /*#__PURE__*/ _interopRequireDefault(require(\"../util/parseObjectStyles\"));\nconst _prefixSelector = /*#__PURE__*/ _interopRequireDefault(require(\"../util/prefixSelector\"));\nconst _isPlainObject = /*#__PURE__*/ _interopRequireDefault(require(\"../util/isPlainObject\"));\nconst _escapeClassName = /*#__PURE__*/ _interopRequireDefault(require(\"../util/escapeClassName\"));\nconst _nameClass = /*#__PURE__*/ _interopRequireWildcard(require(\"../util/nameClass\"));\nconst _pluginUtils = require(\"../util/pluginUtils\");\nconst _corePlugins = require(\"../corePlugins\");\nconst _sharedState = /*#__PURE__*/ _interopRequireWildcard(require(\"./sharedState\"));\nconst _toPath = require(\"../util/toPath\");\nconst _log = /*#__PURE__*/ _interopRequireDefault(require(\"../util/log\"));\nconst _negateValue = /*#__PURE__*/ _interopRequireDefault(require(\"../util/negateValue\"));\nconst _isValidArbitraryValue = /*#__PURE__*/ _interopRequireDefault(require(\"../util/isValidArbitraryValue\"));\nconst _generateRules = require(\"./generateRules\");\nconst _cacheInvalidationJs = require(\"./cacheInvalidation.js\");\nconst _offsetsJs = require(\"./offsets.js\");\nconst _featureFlagsJs = require(\"../featureFlags.js\");\nconst _formatVariantSelector = require(\"../util/formatVariantSelector\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nconst VARIANT_TYPES = {\n    AddVariant: Symbol.for(\"ADD_VARIANT\"),\n    MatchVariant: Symbol.for(\"MATCH_VARIANT\")\n};\nconst VARIANT_INFO = {\n    Base: 1 << 0,\n    Dynamic: 1 << 1\n};\nfunction prefix(context, selector) {\n    let prefix = context.tailwindConfig.prefix;\n    return typeof prefix === \"function\" ? prefix(selector) : prefix + selector;\n}\nfunction normalizeOptionTypes({ type =\"any\" , ...options }) {\n    let types = [].concat(type);\n    return {\n        ...options,\n        types: types.map((type)=>{\n            if (Array.isArray(type)) {\n                return {\n                    type: type[0],\n                    ...type[1]\n                };\n            }\n            return {\n                type,\n                preferOnConflict: false\n            };\n        })\n    };\n}\nfunction parseVariantFormatString(input) {\n    if (input.includes(\"{\")) {\n        if (!isBalanced(input)) throw new Error(`Your { and } are unbalanced.`);\n        return input.split(/{(.*)}/gim).flatMap((line)=>parseVariantFormatString(line)).filter(Boolean);\n    }\n    return [\n        input.trim()\n    ];\n}\nfunction isBalanced(input) {\n    let count = 0;\n    for (let char of input){\n        if (char === \"{\") {\n            count++;\n        } else if (char === \"}\") {\n            if (--count < 0) {\n                return false // unbalanced\n                ;\n            }\n        }\n    }\n    return count === 0;\n}\nfunction insertInto(list, value, { before =[]  } = {}) {\n    before = [].concat(before);\n    if (before.length <= 0) {\n        list.push(value);\n        return;\n    }\n    let idx = list.length - 1;\n    for (let other of before){\n        let iidx = list.indexOf(other);\n        if (iidx === -1) continue;\n        idx = Math.min(idx, iidx);\n    }\n    list.splice(idx, 0, value);\n}\nfunction parseStyles(styles) {\n    if (!Array.isArray(styles)) {\n        return parseStyles([\n            styles\n        ]);\n    }\n    return styles.flatMap((style)=>{\n        let isNode = !Array.isArray(style) && !(0, _isPlainObject.default)(style);\n        return isNode ? style : (0, _parseObjectStyles.default)(style);\n    });\n}\nfunction getClasses(selector, mutate) {\n    let parser = (0, _postcssSelectorParser.default)((selectors)=>{\n        let allClasses = [];\n        if (mutate) {\n            mutate(selectors);\n        }\n        selectors.walkClasses((classNode)=>{\n            allClasses.push(classNode.value);\n        });\n        return allClasses;\n    });\n    return parser.transformSync(selector);\n}\nfunction extractCandidates(node, state = {\n    containsNonOnDemandable: false\n}, depth = 0) {\n    let classes = [];\n    // Handle normal rules\n    if (node.type === \"rule\") {\n        // Ignore everything inside a :not(...). This allows you to write code like\n        // `div:not(.foo)`. If `.foo` is never found in your code, then we used to\n        // not generated it. But now we will ignore everything inside a `:not`, so\n        // that it still gets generated.\n        function ignoreNot(selectors) {\n            selectors.walkPseudos((pseudo)=>{\n                if (pseudo.value === \":not\") {\n                    pseudo.remove();\n                }\n            });\n        }\n        for (let selector of node.selectors){\n            let classCandidates = getClasses(selector, ignoreNot);\n            // At least one of the selectors contains non-\"on-demandable\" candidates.\n            if (classCandidates.length === 0) {\n                state.containsNonOnDemandable = true;\n            }\n            for (let classCandidate of classCandidates){\n                classes.push(classCandidate);\n            }\n        }\n    } else if (node.type === \"atrule\") {\n        node.walkRules((rule)=>{\n            for (let classCandidate of rule.selectors.flatMap((selector)=>getClasses(selector))){\n                classes.push(classCandidate);\n            }\n        });\n    }\n    if (depth === 0) {\n        return [\n            state.containsNonOnDemandable || classes.length === 0,\n            classes\n        ];\n    }\n    return classes;\n}\nfunction withIdentifiers(styles) {\n    return parseStyles(styles).flatMap((node)=>{\n        let nodeMap = new Map();\n        let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node);\n        // If this isn't \"on-demandable\", assign it a universal candidate to always include it.\n        if (containsNonOnDemandableSelectors) {\n            candidates.unshift(_sharedState.NOT_ON_DEMAND);\n        }\n        // However, it could be that it also contains \"on-demandable\" candidates.\n        // E.g.: `span, .foo {}`, in that case it should still be possible to use\n        // `@apply foo` for example.\n        return candidates.map((c)=>{\n            if (!nodeMap.has(node)) {\n                nodeMap.set(node, node);\n            }\n            return [\n                c,\n                nodeMap.get(node)\n            ];\n        });\n    });\n}\nfunction isValidVariantFormatString(format) {\n    return format.startsWith(\"@\") || format.includes(\"&\");\n}\nfunction parseVariant(variant) {\n    variant = variant.replace(/\\n+/g, \"\").replace(/\\s{1,}/g, \" \").trim();\n    let fns = parseVariantFormatString(variant).map((str)=>{\n        if (!str.startsWith(\"@\")) {\n            return ({ format  })=>format(str);\n        }\n        let [, name, params] = /@(.*?)( .+|[({].*)/g.exec(str);\n        return ({ wrap  })=>wrap(_postcss.default.atRule({\n                name,\n                params: params.trim()\n            }));\n    }).reverse();\n    return (api)=>{\n        for (let fn of fns){\n            fn(api);\n        }\n    };\n}\n/**\n *\n * @param {any} tailwindConfig\n * @param {any} context\n * @param {object} param2\n * @param {Offsets} param2.offsets\n */ function buildPluginApi(tailwindConfig, context, { variantList , variantMap , offsets , classList  }) {\n    function getConfigValue(path, defaultValue) {\n        return path ? (0, _dlv.default)(tailwindConfig, path, defaultValue) : tailwindConfig;\n    }\n    function applyConfiguredPrefix(selector) {\n        return (0, _prefixSelector.default)(tailwindConfig.prefix, selector);\n    }\n    function prefixIdentifier(identifier, options) {\n        if (identifier === _sharedState.NOT_ON_DEMAND) {\n            return _sharedState.NOT_ON_DEMAND;\n        }\n        if (!options.respectPrefix) {\n            return identifier;\n        }\n        return context.tailwindConfig.prefix + identifier;\n    }\n    function resolveThemeValue(path, defaultValue, opts = {}) {\n        const [pathRoot, ...subPaths] = (0, _toPath.toPath)(path);\n        const value = getConfigValue([\n            \"theme\",\n            pathRoot,\n            ...subPaths\n        ], defaultValue);\n        return (0, _transformThemeValue.default)(pathRoot)(value, opts);\n    }\n    const theme = Object.assign((path, defaultValue = undefined)=>resolveThemeValue(path, defaultValue), {\n        withAlpha: (path, opacityValue)=>resolveThemeValue(path, undefined, {\n                opacityValue\n            })\n    });\n    let variantIdentifier = 0;\n    let api = {\n        postcss: _postcss.default,\n        prefix: applyConfiguredPrefix,\n        e: _escapeClassName.default,\n        config: getConfigValue,\n        theme,\n        corePlugins: (path)=>{\n            if (Array.isArray(tailwindConfig.corePlugins)) {\n                return tailwindConfig.corePlugins.includes(path);\n            }\n            return getConfigValue([\n                \"corePlugins\",\n                path\n            ], true);\n        },\n        variants: ()=>{\n            // Preserved for backwards compatibility but not used in v3.0+\n            return [];\n        },\n        addBase (base) {\n            for (let [identifier, rule] of withIdentifiers(base)){\n                let prefixedIdentifier = prefixIdentifier(identifier, {});\n                let offset = offsets.create(\"base\");\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offset,\n                        layer: \"base\"\n                    },\n                    rule\n                ]);\n            }\n        },\n        /**\n     * @param {string} group\n     * @param {Record<string, string | string[]>} declarations\n     */ addDefaults (group, declarations) {\n            const groups = {\n                [`@defaults ${group}`]: declarations\n            };\n            for (let [identifier, rule] of withIdentifiers(groups)){\n                let prefixedIdentifier = prefixIdentifier(identifier, {});\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offsets.create(\"defaults\"),\n                        layer: \"defaults\"\n                    },\n                    rule\n                ]);\n            }\n        },\n        addComponents (components, options) {\n            let defaultOptions = {\n                preserveSource: false,\n                respectPrefix: true,\n                respectImportant: false\n            };\n            options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n            for (let [identifier, rule] of withIdentifiers(components)){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                classList.add(prefixedIdentifier);\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offsets.create(\"components\"),\n                        layer: \"components\",\n                        options\n                    },\n                    rule\n                ]);\n            }\n        },\n        addUtilities (utilities, options) {\n            let defaultOptions = {\n                preserveSource: false,\n                respectPrefix: true,\n                respectImportant: true\n            };\n            options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n            for (let [identifier, rule] of withIdentifiers(utilities)){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                classList.add(prefixedIdentifier);\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offsets.create(\"utilities\"),\n                        layer: \"utilities\",\n                        options\n                    },\n                    rule\n                ]);\n            }\n        },\n        matchUtilities: function(utilities, options) {\n            let defaultOptions = {\n                respectPrefix: true,\n                respectImportant: true,\n                modifiers: false\n            };\n            options = normalizeOptionTypes({\n                ...defaultOptions,\n                ...options\n            });\n            let offset = offsets.create(\"utilities\");\n            for(let identifier in utilities){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                let rule = utilities[identifier];\n                classList.add([\n                    prefixedIdentifier,\n                    options\n                ]);\n                function wrapped(modifier, { isOnlyPlugin  }) {\n                    let [value, coercedType, utilityModifier] = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig);\n                    if (value === undefined) {\n                        return [];\n                    }\n                    if (!options.types.some(({ type  })=>type === coercedType)) {\n                        if (isOnlyPlugin) {\n                            _log.default.warn([\n                                `Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`,\n                                `You can safely update it to \\`${identifier}-${modifier.replace(coercedType + \":\", \"\")}\\`.`\n                            ]);\n                        } else {\n                            return [];\n                        }\n                    }\n                    if (!(0, _isValidArbitraryValue.default)(value)) {\n                        return [];\n                    }\n                    let extras = {\n                        get modifier () {\n                            if (!options.modifiers) {\n                                _log.default.warn(`modifier-used-without-options-for-${identifier}`, [\n                                    \"Your plugin must set `modifiers: true` in its options to support modifiers.\"\n                                ]);\n                            }\n                            return utilityModifier;\n                        }\n                    };\n                    let modifiersEnabled = (0, _featureFlagsJs.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n                    let ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map((declaration)=>({\n                            [(0, _nameClass.default)(identifier, modifier)]: declaration\n                        }));\n                    return ruleSets;\n                }\n                let withOffsets = [\n                    {\n                        sort: offset,\n                        layer: \"utilities\",\n                        options\n                    },\n                    wrapped\n                ];\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n            }\n        },\n        matchComponents: function(components, options) {\n            let defaultOptions = {\n                respectPrefix: true,\n                respectImportant: false,\n                modifiers: false\n            };\n            options = normalizeOptionTypes({\n                ...defaultOptions,\n                ...options\n            });\n            let offset = offsets.create(\"components\");\n            for(let identifier in components){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                let rule = components[identifier];\n                classList.add([\n                    prefixedIdentifier,\n                    options\n                ]);\n                function wrapped(modifier, { isOnlyPlugin  }) {\n                    let [value, coercedType, utilityModifier] = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig);\n                    if (value === undefined) {\n                        return [];\n                    }\n                    if (!options.types.some(({ type  })=>type === coercedType)) {\n                        if (isOnlyPlugin) {\n                            _log.default.warn([\n                                `Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`,\n                                `You can safely update it to \\`${identifier}-${modifier.replace(coercedType + \":\", \"\")}\\`.`\n                            ]);\n                        } else {\n                            return [];\n                        }\n                    }\n                    if (!(0, _isValidArbitraryValue.default)(value)) {\n                        return [];\n                    }\n                    let extras = {\n                        get modifier () {\n                            if (!options.modifiers) {\n                                _log.default.warn(`modifier-used-without-options-for-${identifier}`, [\n                                    \"Your plugin must set `modifiers: true` in its options to support modifiers.\"\n                                ]);\n                            }\n                            return utilityModifier;\n                        }\n                    };\n                    let modifiersEnabled = (0, _featureFlagsJs.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n                    let ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map((declaration)=>({\n                            [(0, _nameClass.default)(identifier, modifier)]: declaration\n                        }));\n                    return ruleSets;\n                }\n                let withOffsets = [\n                    {\n                        sort: offset,\n                        layer: \"components\",\n                        options\n                    },\n                    wrapped\n                ];\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n            }\n        },\n        addVariant (variantName, variantFunctions, options = {}) {\n            variantFunctions = [].concat(variantFunctions).map((variantFunction)=>{\n                if (typeof variantFunction !== \"string\") {\n                    // Safelist public API functions\n                    return (api = {})=>{\n                        let { args , modifySelectors , container , separator , wrap , format  } = api;\n                        let result = variantFunction(Object.assign({\n                            modifySelectors,\n                            container,\n                            separator\n                        }, options.type === VARIANT_TYPES.MatchVariant && {\n                            args,\n                            wrap,\n                            format\n                        }));\n                        if (typeof result === \"string\" && !isValidVariantFormatString(result)) {\n                            throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n                        }\n                        if (Array.isArray(result)) {\n                            return result.filter((variant)=>typeof variant === \"string\").map((variant)=>parseVariant(variant));\n                        }\n                        // result may be undefined with legacy variants that use APIs like `modifySelectors`\n                        // result may also be a postcss node if someone was returning the result from `modifySelectors`\n                        return result && typeof result === \"string\" && parseVariant(result)(api);\n                    };\n                }\n                if (!isValidVariantFormatString(variantFunction)) {\n                    throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n                }\n                return parseVariant(variantFunction);\n            });\n            insertInto(variantList, variantName, options);\n            variantMap.set(variantName, variantFunctions);\n            context.variantOptions.set(variantName, options);\n        },\n        matchVariant (variant, variantFn, options) {\n            var ref;\n            // A unique identifier that \"groups\" these variants together.\n            // This is for internal use only which is why it is not present in the types\n            let id = (ref = options === null || options === void 0 ? void 0 : options.id) !== null && ref !== void 0 ? ref : ++variantIdentifier;\n            let isSpecial = variant === \"@\";\n            let modifiersEnabled = (0, _featureFlagsJs.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n            var ref1;\n            for (let [key, value] of Object.entries((ref1 = options === null || options === void 0 ? void 0 : options.values) !== null && ref1 !== void 0 ? ref1 : {})){\n                if (key === \"DEFAULT\") continue;\n                api.addVariant(isSpecial ? `${variant}${key}` : `${variant}-${key}`, ({ args , container  })=>{\n                    return variantFn(value, modifiersEnabled ? {\n                        modifier: args === null || args === void 0 ? void 0 : args.modifier,\n                        container\n                    } : {\n                        container\n                    });\n                }, {\n                    ...options,\n                    value,\n                    id,\n                    type: VARIANT_TYPES.MatchVariant,\n                    variantInfo: VARIANT_INFO.Base\n                });\n            }\n            var ref2;\n            let hasDefault = \"DEFAULT\" in ((ref2 = options === null || options === void 0 ? void 0 : options.values) !== null && ref2 !== void 0 ? ref2 : {});\n            api.addVariant(variant, ({ args , container  })=>{\n                if ((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE && !hasDefault) {\n                    return null;\n                }\n                var // (JetBrains) plugins.\n                ref;\n                return variantFn((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE ? options.values.DEFAULT : (ref = args === null || args === void 0 ? void 0 : args.value) !== null && ref !== void 0 ? ref : typeof args === \"string\" ? args : \"\", modifiersEnabled ? {\n                    modifier: args === null || args === void 0 ? void 0 : args.modifier,\n                    container\n                } : {\n                    container\n                });\n            }, {\n                ...options,\n                id,\n                type: VARIANT_TYPES.MatchVariant,\n                variantInfo: VARIANT_INFO.Dynamic\n            });\n        }\n    };\n    return api;\n}\nlet fileModifiedMapCache = new WeakMap();\nfunction getFileModifiedMap(context) {\n    if (!fileModifiedMapCache.has(context)) {\n        fileModifiedMapCache.set(context, new Map());\n    }\n    return fileModifiedMapCache.get(context);\n}\nfunction trackModified(files, fileModifiedMap) {\n    let changed = false;\n    for (let file of files){\n        var ref;\n        if (!file) continue;\n        let parsed = _url.default.parse(file);\n        let pathname = parsed.hash ? parsed.href.replace(parsed.hash, \"\") : parsed.href;\n        pathname = parsed.search ? pathname.replace(parsed.search, \"\") : pathname;\n        let newModified = (ref = _fs.default.statSync(decodeURIComponent(pathname), {\n            throwIfNoEntry: false\n        })) === null || ref === void 0 ? void 0 : ref.mtimeMs;\n        if (!newModified) {\n            continue;\n        }\n        if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) {\n            changed = true;\n        }\n        fileModifiedMap.set(file, newModified);\n    }\n    return changed;\n}\nfunction extractVariantAtRules(node) {\n    node.walkAtRules((atRule)=>{\n        if ([\n            \"responsive\",\n            \"variants\"\n        ].includes(atRule.name)) {\n            extractVariantAtRules(atRule);\n            atRule.before(atRule.nodes);\n            atRule.remove();\n        }\n    });\n}\nfunction collectLayerPlugins(root) {\n    let layerPlugins = [];\n    root.each((node)=>{\n        if (node.type === \"atrule\" && [\n            \"responsive\",\n            \"variants\"\n        ].includes(node.name)) {\n            node.name = \"layer\";\n            node.params = \"utilities\";\n        }\n    });\n    // Walk @layer rules and treat them like plugins\n    root.walkAtRules(\"layer\", (layerRule)=>{\n        extractVariantAtRules(layerRule);\n        if (layerRule.params === \"base\") {\n            for (let node of layerRule.nodes){\n                layerPlugins.push(function({ addBase  }) {\n                    addBase(node, {\n                        respectPrefix: false\n                    });\n                });\n            }\n            layerRule.remove();\n        } else if (layerRule.params === \"components\") {\n            for (let node1 of layerRule.nodes){\n                layerPlugins.push(function({ addComponents  }) {\n                    addComponents(node1, {\n                        respectPrefix: false,\n                        preserveSource: true\n                    });\n                });\n            }\n            layerRule.remove();\n        } else if (layerRule.params === \"utilities\") {\n            for (let node2 of layerRule.nodes){\n                layerPlugins.push(function({ addUtilities  }) {\n                    addUtilities(node2, {\n                        respectPrefix: false,\n                        preserveSource: true\n                    });\n                });\n            }\n            layerRule.remove();\n        }\n    });\n    return layerPlugins;\n}\nfunction resolvePlugins(context, root) {\n    let corePluginList = Object.entries({\n        ..._corePlugins.variantPlugins,\n        ..._corePlugins.corePlugins\n    }).map(([name, plugin])=>{\n        if (!context.tailwindConfig.corePlugins.includes(name)) {\n            return null;\n        }\n        return plugin;\n    }).filter(Boolean);\n    let userPlugins = context.tailwindConfig.plugins.map((plugin)=>{\n        if (plugin.__isOptionsFunction) {\n            plugin = plugin();\n        }\n        return typeof plugin === \"function\" ? plugin : plugin.handler;\n    });\n    let layerPlugins = collectLayerPlugins(root);\n    // TODO: This is a workaround for backwards compatibility, since custom variants\n    // were historically sorted before screen/stackable variants.\n    let beforeVariants = [\n        _corePlugins.variantPlugins[\"pseudoElementVariants\"],\n        _corePlugins.variantPlugins[\"pseudoClassVariants\"],\n        _corePlugins.variantPlugins[\"ariaVariants\"],\n        _corePlugins.variantPlugins[\"dataVariants\"]\n    ];\n    let afterVariants = [\n        _corePlugins.variantPlugins[\"supportsVariants\"],\n        _corePlugins.variantPlugins[\"directionVariants\"],\n        _corePlugins.variantPlugins[\"reducedMotionVariants\"],\n        _corePlugins.variantPlugins[\"prefersContrastVariants\"],\n        _corePlugins.variantPlugins[\"darkVariants\"],\n        _corePlugins.variantPlugins[\"printVariant\"],\n        _corePlugins.variantPlugins[\"screenVariants\"],\n        _corePlugins.variantPlugins[\"orientationVariants\"]\n    ];\n    return [\n        ...corePluginList,\n        ...beforeVariants,\n        ...userPlugins,\n        ...afterVariants,\n        ...layerPlugins\n    ];\n}\nfunction registerPlugins(plugins, context) {\n    let variantList = [];\n    let variantMap = new Map();\n    context.variantMap = variantMap;\n    let offsets = new _offsetsJs.Offsets();\n    context.offsets = offsets;\n    let classList = new Set();\n    let pluginApi = buildPluginApi(context.tailwindConfig, context, {\n        variantList,\n        variantMap,\n        offsets,\n        classList\n    });\n    for (let plugin of plugins){\n        if (Array.isArray(plugin)) {\n            for (let pluginItem of plugin){\n                pluginItem(pluginApi);\n            }\n        } else {\n            plugin === null || plugin === void 0 ? void 0 : plugin(pluginApi);\n        }\n    }\n    // Make sure to record bit masks for every variant\n    offsets.recordVariants(variantList, (variant)=>variantMap.get(variant).length);\n    // Build variantMap\n    for (let [variantName, variantFunctions] of variantMap.entries()){\n        context.variantMap.set(variantName, variantFunctions.map((variantFunction, idx)=>[\n                offsets.forVariant(variantName, idx),\n                variantFunction\n            ]));\n    }\n    var _safelist;\n    let safelist = ((_safelist = context.tailwindConfig.safelist) !== null && _safelist !== void 0 ? _safelist : []).filter(Boolean);\n    if (safelist.length > 0) {\n        let checks = [];\n        for (let value of safelist){\n            if (typeof value === \"string\") {\n                context.changedContent.push({\n                    content: value,\n                    extension: \"html\"\n                });\n                continue;\n            }\n            if (value instanceof RegExp) {\n                _log.default.warn(\"root-regex\", [\n                    \"Regular expressions in `safelist` work differently in Tailwind CSS v3.0.\",\n                    \"Update your `safelist` configuration to eliminate this warning.\",\n                    \"https://tailwindcss.com/docs/content-configuration#safelisting-classes\"\n                ]);\n                continue;\n            }\n            checks.push(value);\n        }\n        if (checks.length > 0) {\n            let patternMatchingCount = new Map();\n            let prefixLength = context.tailwindConfig.prefix.length;\n            let checkImportantUtils = checks.some((check)=>check.pattern.source.includes(\"!\"));\n            for (let util of classList){\n                let utils = Array.isArray(util) ? (()=>{\n                    let [utilName, options] = util;\n                    var ref;\n                    let values = Object.keys((ref = options === null || options === void 0 ? void 0 : options.values) !== null && ref !== void 0 ? ref : {});\n                    let classes = values.map((value)=>(0, _nameClass.formatClass)(utilName, value));\n                    if (options === null || options === void 0 ? void 0 : options.supportsNegativeValues) {\n                        // This is the normal negated version\n                        // e.g. `-inset-1` or `-tw-inset-1`\n                        classes = [\n                            ...classes,\n                            ...classes.map((cls)=>\"-\" + cls)\n                        ];\n                        // This is the negated version *after* the prefix\n                        // e.g. `tw--inset-1`\n                        // The prefix is already attached to util name\n                        // So we add the negative after the prefix\n                        classes = [\n                            ...classes,\n                            ...classes.map((cls)=>cls.slice(0, prefixLength) + \"-\" + cls.slice(prefixLength))\n                        ];\n                    }\n                    if (options.types.some(({ type  })=>type === \"color\")) {\n                        classes = [\n                            ...classes,\n                            ...classes.flatMap((cls)=>Object.keys(context.tailwindConfig.theme.opacity).map((opacity)=>`${cls}/${opacity}`))\n                        ];\n                    }\n                    if (checkImportantUtils && (options === null || options === void 0 ? void 0 : options.respectImportant)) {\n                        classes = [\n                            ...classes,\n                            ...classes.map((cls)=>\"!\" + cls)\n                        ];\n                    }\n                    return classes;\n                })() : [\n                    util\n                ];\n                for (let util1 of utils){\n                    for (let { pattern , variants =[]  } of checks){\n                        // RegExp with the /g flag are stateful, so let's reset the last\n                        // index pointer to reset the state.\n                        pattern.lastIndex = 0;\n                        if (!patternMatchingCount.has(pattern)) {\n                            patternMatchingCount.set(pattern, 0);\n                        }\n                        if (!pattern.test(util1)) continue;\n                        patternMatchingCount.set(pattern, patternMatchingCount.get(pattern) + 1);\n                        context.changedContent.push({\n                            content: util1,\n                            extension: \"html\"\n                        });\n                        for (let variant of variants){\n                            context.changedContent.push({\n                                content: variant + context.tailwindConfig.separator + util1,\n                                extension: \"html\"\n                            });\n                        }\n                    }\n                }\n            }\n            for (let [regex, count] of patternMatchingCount.entries()){\n                if (count !== 0) continue;\n                _log.default.warn([\n                    `The safelist pattern \\`${regex}\\` doesn't match any Tailwind CSS classes.`,\n                    \"Fix this pattern or remove it from your `safelist` configuration.\",\n                    \"https://tailwindcss.com/docs/content-configuration#safelisting-classes\"\n                ]);\n            }\n        }\n    }\n    var _darkMode, ref;\n    let darkClassName = (ref = [].concat((_darkMode = context.tailwindConfig.darkMode) !== null && _darkMode !== void 0 ? _darkMode : \"media\")[1]) !== null && ref !== void 0 ? ref : \"dark\";\n    // A list of utilities that are used by certain Tailwind CSS utilities but\n    // that don't exist on their own. This will result in them \"not existing\" and\n    // sorting could be weird since you still require them in order to make the\n    // host utilities work properly. (Thanks Biology)\n    let parasiteUtilities = [\n        prefix(context, darkClassName),\n        prefix(context, \"group\"),\n        prefix(context, \"peer\")\n    ];\n    context.getClassOrder = function getClassOrder(classes) {\n        // Non-util classes won't be generated, so we default them to null\n        let sortedClassNames = new Map(classes.map((className)=>[\n                className,\n                null\n            ]));\n        // Sort all classes in order\n        // Non-tailwind classes won't be generated and will be left as `null`\n        let rules = (0, _generateRules.generateRules)(new Set(classes), context);\n        rules = context.offsets.sort(rules);\n        let idx = BigInt(parasiteUtilities.length);\n        for (const [, rule] of rules){\n            sortedClassNames.set(rule.raws.tailwind.candidate, idx++);\n        }\n        return classes.map((className)=>{\n            var ref;\n            let order = (ref = sortedClassNames.get(className)) !== null && ref !== void 0 ? ref : null;\n            let parasiteIndex = parasiteUtilities.indexOf(className);\n            if (order === null && parasiteIndex !== -1) {\n                // This will make sure that it is at the very beginning of the\n                // `components` layer which technically means 'before any\n                // components'.\n                order = BigInt(parasiteIndex);\n            }\n            return [\n                className,\n                order\n            ];\n        });\n    };\n    // Generate a list of strings for autocompletion purposes, e.g.\n    // ['uppercase', 'lowercase', ...]\n    context.getClassList = function getClassList() {\n        let output = [];\n        for (let util of classList){\n            if (Array.isArray(util)) {\n                let [utilName, options] = util;\n                let negativeClasses = [];\n                var ref;\n                for (let [key, value] of Object.entries((ref = options === null || options === void 0 ? void 0 : options.values) !== null && ref !== void 0 ? ref : {})){\n                    // Ignore undefined and null values\n                    if (value == null) {\n                        continue;\n                    }\n                    output.push((0, _nameClass.formatClass)(utilName, key));\n                    if ((options === null || options === void 0 ? void 0 : options.supportsNegativeValues) && (0, _negateValue.default)(value)) {\n                        negativeClasses.push((0, _nameClass.formatClass)(utilName, `-${key}`));\n                    }\n                }\n                output.push(...negativeClasses);\n            } else {\n                output.push(util);\n            }\n        }\n        return output;\n    };\n    // Generate a list of available variants with meta information of the type of variant.\n    context.getVariants = function getVariants() {\n        let result = [];\n        for (let [name, options] of context.variantOptions.entries()){\n            if (options.variantInfo === VARIANT_INFO.Base) continue;\n            var _values;\n            result.push({\n                name,\n                isArbitrary: options.type === Symbol.for(\"MATCH_VARIANT\"),\n                values: Object.keys((_values = options.values) !== null && _values !== void 0 ? _values : {}),\n                hasDash: name !== \"@\",\n                selectors ({ modifier , value  } = {}) {\n                    let candidate = \"__TAILWIND_PLACEHOLDER__\";\n                    let rule = _postcss.default.rule({\n                        selector: `.${candidate}`\n                    });\n                    let container = _postcss.default.root({\n                        nodes: [\n                            rule.clone()\n                        ]\n                    });\n                    let before = container.toString();\n                    var ref;\n                    let fns = ((ref = context.variantMap.get(name)) !== null && ref !== void 0 ? ref : []).flatMap(([_, fn])=>fn);\n                    let formatStrings = [];\n                    for (let fn of fns){\n                        var ref1;\n                        let localFormatStrings = [];\n                        var ref2;\n                        let api = {\n                            args: {\n                                modifier,\n                                value: (ref2 = (ref1 = options.values) === null || ref1 === void 0 ? void 0 : ref1[value]) !== null && ref2 !== void 0 ? ref2 : value\n                            },\n                            separator: context.tailwindConfig.separator,\n                            modifySelectors (modifierFunction) {\n                                // Run the modifierFunction over each rule\n                                container.each((rule)=>{\n                                    if (rule.type !== \"rule\") {\n                                        return;\n                                    }\n                                    rule.selectors = rule.selectors.map((selector)=>{\n                                        return modifierFunction({\n                                            get className () {\n                                                return (0, _generateRules.getClassNameFromSelector)(selector);\n                                            },\n                                            selector\n                                        });\n                                    });\n                                });\n                                return container;\n                            },\n                            format (str) {\n                                localFormatStrings.push(str);\n                            },\n                            wrap (wrapper) {\n                                localFormatStrings.push(`@${wrapper.name} ${wrapper.params} { & }`);\n                            },\n                            container\n                        };\n                        let ruleWithVariant = fn(api);\n                        if (localFormatStrings.length > 0) {\n                            formatStrings.push(localFormatStrings);\n                        }\n                        if (Array.isArray(ruleWithVariant)) {\n                            for (let variantFunction of ruleWithVariant){\n                                localFormatStrings = [];\n                                variantFunction(api);\n                                formatStrings.push(localFormatStrings);\n                            }\n                        }\n                    }\n                    // Reverse engineer the result of the `container`\n                    let manualFormatStrings = [];\n                    let after = container.toString();\n                    if (before !== after) {\n                        // Figure out all selectors\n                        container.walkRules((rule)=>{\n                            let modified = rule.selector;\n                            // Rebuild the base selector, this is what plugin authors would do\n                            // as well. E.g.: `${variant}${separator}${className}`.\n                            // However, plugin authors probably also prepend or append certain\n                            // classes, pseudos, ids, ...\n                            let rebuiltBase = (0, _postcssSelectorParser.default)((selectors)=>{\n                                selectors.walkClasses((classNode)=>{\n                                    classNode.value = `${name}${context.tailwindConfig.separator}${classNode.value}`;\n                                });\n                            }).processSync(modified);\n                            // Now that we know the original selector, the new selector, and\n                            // the rebuild part in between, we can replace the part that plugin\n                            // authors need to rebuild with `&`, and eventually store it in the\n                            // collectedFormats. Similar to what `format('...')` would do.\n                            //\n                            // E.g.:\n                            //                   variant: foo\n                            //                  selector: .markdown > p\n                            //      modified (by plugin): .foo .foo\\\\:markdown > p\n                            //    rebuiltBase (internal): .foo\\\\:markdown > p\n                            //                    format: .foo &\n                            manualFormatStrings.push(modified.replace(rebuiltBase, \"&\").replace(candidate, \"&\"));\n                        });\n                        // Figure out all atrules\n                        container.walkAtRules((atrule)=>{\n                            manualFormatStrings.push(`@${atrule.name} (${atrule.params}) { & }`);\n                        });\n                    }\n                    var _values;\n                    let result = formatStrings.map((formatString)=>(0, _formatVariantSelector.finalizeSelector)((0, _formatVariantSelector.formatVariantSelector)(\"&\", ...formatString), {\n                            selector: `.${candidate}`,\n                            candidate,\n                            context,\n                            isArbitraryVariant: !(value in ((_values = options.values) !== null && _values !== void 0 ? _values : {}))\n                        }).replace(`.${candidate}`, \"&\").replace(\"{ & }\", \"\").trim());\n                    if (manualFormatStrings.length > 0) {\n                        result.push((0, _formatVariantSelector.formatVariantSelector)(\"&\", ...manualFormatStrings));\n                    }\n                    return result;\n                }\n            });\n        }\n        return result;\n    };\n}\n/**\n * Mark as class as retroactively invalid\n *\n *\n * @param {string} candidate\n */ function markInvalidUtilityCandidate(context, candidate) {\n    if (!context.classCache.has(candidate)) {\n        return;\n    }\n    // Mark this as not being a real utility\n    context.notClassCache.add(candidate);\n    // Remove it from any candidate-specific caches\n    context.classCache.delete(candidate);\n    context.applyClassCache.delete(candidate);\n    context.candidateRuleMap.delete(candidate);\n    context.candidateRuleCache.delete(candidate);\n    // Ensure the stylesheet gets rebuilt\n    context.stylesheetCache = null;\n}\n/**\n * Mark as class as retroactively invalid\n *\n * @param {import('postcss').Node} node\n */ function markInvalidUtilityNode(context, node) {\n    let candidate = node.raws.tailwind.candidate;\n    if (!candidate) {\n        return;\n    }\n    for (const entry of context.ruleCache){\n        if (entry[1].raws.tailwind.candidate === candidate) {\n            context.ruleCache.delete(entry);\n        // context.postCssNodeCache.delete(node)\n        }\n    }\n    markInvalidUtilityCandidate(context, candidate);\n}\nfunction createContext(tailwindConfig, changedContent = [], root = _postcss.default.root()) {\n    var _blocklist;\n    let context = {\n        disposables: [],\n        ruleCache: new Set(),\n        candidateRuleCache: new Map(),\n        classCache: new Map(),\n        applyClassCache: new Map(),\n        // Seed the not class cache with the blocklist (which is only strings)\n        notClassCache: new Set((_blocklist = tailwindConfig.blocklist) !== null && _blocklist !== void 0 ? _blocklist : []),\n        postCssNodeCache: new Map(),\n        candidateRuleMap: new Map(),\n        tailwindConfig,\n        changedContent: changedContent,\n        variantMap: new Map(),\n        stylesheetCache: null,\n        variantOptions: new Map(),\n        markInvalidUtilityCandidate: (candidate)=>markInvalidUtilityCandidate(context, candidate),\n        markInvalidUtilityNode: (node)=>markInvalidUtilityNode(context, node)\n    };\n    let resolvedPlugins = resolvePlugins(context, root);\n    registerPlugins(resolvedPlugins, context);\n    return context;\n}\nlet contextMap = _sharedState.contextMap;\nlet configContextMap = _sharedState.configContextMap;\nlet contextSourcesMap = _sharedState.contextSourcesMap;\nfunction getContext(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies) {\n    let sourcePath = result.opts.from;\n    let isConfigFile = userConfigPath !== null;\n    _sharedState.env.DEBUG && console.log(\"Source path:\", sourcePath);\n    let existingContext;\n    if (isConfigFile && contextMap.has(sourcePath)) {\n        existingContext = contextMap.get(sourcePath);\n    } else if (configContextMap.has(tailwindConfigHash)) {\n        let context = configContextMap.get(tailwindConfigHash);\n        contextSourcesMap.get(context).add(sourcePath);\n        contextMap.set(sourcePath, context);\n        existingContext = context;\n    }\n    let cssDidChange = (0, _cacheInvalidationJs.hasContentChanged)(sourcePath, root);\n    // If there's already a context in the cache and we don't need to\n    // reset the context, return the cached context.\n    if (existingContext) {\n        let contextDependenciesChanged = trackModified([\n            ...contextDependencies\n        ], getFileModifiedMap(existingContext));\n        if (!contextDependenciesChanged && !cssDidChange) {\n            return [\n                existingContext,\n                false\n            ];\n        }\n    }\n    // If this source is in the context map, get the old context.\n    // Remove this source from the context sources for the old context,\n    // and clean up that context if no one else is using it. This can be\n    // called by many processes in rapid succession, so we check for presence\n    // first because the first process to run this code will wipe it out first.\n    if (contextMap.has(sourcePath)) {\n        let oldContext = contextMap.get(sourcePath);\n        if (contextSourcesMap.has(oldContext)) {\n            contextSourcesMap.get(oldContext).delete(sourcePath);\n            if (contextSourcesMap.get(oldContext).size === 0) {\n                contextSourcesMap.delete(oldContext);\n                for (let [tailwindConfigHash1, context1] of configContextMap){\n                    if (context1 === oldContext) {\n                        configContextMap.delete(tailwindConfigHash1);\n                    }\n                }\n                for (let disposable of oldContext.disposables.splice(0)){\n                    disposable(oldContext);\n                }\n            }\n        }\n    }\n    _sharedState.env.DEBUG && console.log(\"Setting up new context...\");\n    let context2 = createContext(tailwindConfig, [], root);\n    Object.assign(context2, {\n        userConfigPath\n    });\n    trackModified([\n        ...contextDependencies\n    ], getFileModifiedMap(context2));\n    // ---\n    // Update all context tracking state\n    configContextMap.set(tailwindConfigHash, context2);\n    contextMap.set(sourcePath, context2);\n    if (!contextSourcesMap.has(context2)) {\n        contextSourcesMap.set(context2, new Set());\n    }\n    contextSourcesMap.get(context2).add(sourcePath);\n    return [\n        context2,\n        true\n    ];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}