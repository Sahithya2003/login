{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports,\n// DISABLE_TOUCH = TRUE\n// Retrieve an existing context from cache if possible (since contexts are unique per\n// source path), or set up a new one (including setting up watchers and registering\n// plugins) then return it\n\"default\", {\n  enumerable: true,\n  get: () => setupTrackingContext\n});\nconst _fs = /*#__PURE__*/_interopRequireDefault(require(\"fs\"));\nconst _quickLru = /*#__PURE__*/_interopRequireDefault(require(\"quick-lru\"));\nconst _hashConfig = /*#__PURE__*/_interopRequireDefault(require(\"../util/hashConfig\"));\nconst _getModuleDependencies = /*#__PURE__*/_interopRequireDefault(require(\"../lib/getModuleDependencies\"));\nconst _resolveConfig = /*#__PURE__*/_interopRequireDefault(require(\"../public/resolve-config\"));\nconst _resolveConfigPath = /*#__PURE__*/_interopRequireDefault(require(\"../util/resolveConfigPath\"));\nconst _setupContextUtils = require(\"./setupContextUtils\");\nconst _parseDependency = /*#__PURE__*/_interopRequireDefault(require(\"../util/parseDependency\"));\nconst _validateConfigJs = require(\"../util/validateConfig.js\");\nconst _contentJs = require(\"./content.js\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nlet configPathCache = new _quickLru.default({\n  maxSize: 100\n});\nlet candidateFilesCache = new WeakMap();\nfunction getCandidateFiles(context, tailwindConfig) {\n  if (candidateFilesCache.has(context)) {\n    return candidateFilesCache.get(context);\n  }\n  let candidateFiles = (0, _contentJs.parseCandidateFiles)(context, tailwindConfig);\n  return candidateFilesCache.set(context, candidateFiles).get(context);\n}\n// Get the config object based on a path\nfunction getTailwindConfig(configOrPath) {\n  let userConfigPath = (0, _resolveConfigPath.default)(configOrPath);\n  if (userConfigPath !== null) {\n    let [prevConfig, prevConfigHash, prevDeps, prevModified] = configPathCache.get(userConfigPath) || [];\n    let newDeps = (0, _getModuleDependencies.default)(userConfigPath).map(dep => dep.file);\n    let modified = false;\n    let newModified = new Map();\n    for (let file of newDeps) {\n      let time = _fs.default.statSync(file).mtimeMs;\n      newModified.set(file, time);\n      if (!prevModified || !prevModified.has(file) || time > prevModified.get(file)) {\n        modified = true;\n      }\n    }\n    // It hasn't changed (based on timestamps)\n    if (!modified) {\n      return [prevConfig, userConfigPath, prevConfigHash, prevDeps];\n    }\n    // It has changed (based on timestamps), or first run\n    for (let file1 of newDeps) {\n      delete require.cache[file1];\n    }\n    let newConfig = (0, _resolveConfig.default)(require(userConfigPath));\n    newConfig = (0, _validateConfigJs.validateConfig)(newConfig);\n    let newHash = (0, _hashConfig.default)(newConfig);\n    configPathCache.set(userConfigPath, [newConfig, newHash, newDeps, newModified]);\n    return [newConfig, userConfigPath, newHash, newDeps];\n  }\n  // It's a plain object, not a path\n  let newConfig1 = (0, _resolveConfig.default)(configOrPath.config === undefined ? configOrPath : configOrPath.config);\n  newConfig1 = (0, _validateConfigJs.validateConfig)(newConfig1);\n  return [newConfig1, null, (0, _hashConfig.default)(newConfig1), []];\n}\nfunction setupTrackingContext(configOrPath) {\n  return _ref => {\n    let {\n      tailwindDirectives,\n      registerDependency\n    } = _ref;\n    return (root, result) => {\n      let [tailwindConfig, userConfigPath, tailwindConfigHash, configDependencies] = getTailwindConfig(configOrPath);\n      let contextDependencies = new Set(configDependencies);\n      // If there are no @tailwind or @apply rules, we don't consider this CSS\n      // file or its dependencies to be dependencies of the context. Can reuse\n      // the context even if they change. We may want to think about `@layer`\n      // being part of this trigger too, but it's tough because it's impossible\n      // for a layer in one file to end up in the actual @tailwind rule in\n      // another file since independent sources are effectively isolated.\n      if (tailwindDirectives.size > 0) {\n        // Add current css file as a context dependencies.\n        contextDependencies.add(result.opts.from);\n        // Add all css @import dependencies as context dependencies.\n        for (let message of result.messages) {\n          if (message.type === \"dependency\") {\n            contextDependencies.add(message.file);\n          }\n        }\n      }\n      let [context] = (0, _setupContextUtils.getContext)(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies);\n      let candidateFiles = getCandidateFiles(context, tailwindConfig);\n      // If there are no @tailwind or @apply rules, we don't consider this CSS file or it's\n      // dependencies to be dependencies of the context. Can reuse the context even if they change.\n      // We may want to think about `@layer` being part of this trigger too, but it's tough\n      // because it's impossible for a layer in one file to end up in the actual @tailwind rule\n      // in another file since independent sources are effectively isolated.\n      if (tailwindDirectives.size > 0) {\n        let fileModifiedMap = (0, _setupContextUtils.getFileModifiedMap)(context);\n        // Add template paths as postcss dependencies.\n        for (let contentPath of candidateFiles) {\n          for (let dependency of (0, _parseDependency.default)(contentPath)) {\n            registerDependency(dependency);\n          }\n        }\n        for (let changedContent of (0, _contentJs.resolvedChangedContent)(context, candidateFiles, fileModifiedMap)) {\n          context.changedContent.push(changedContent);\n        }\n      }\n      for (let file of configDependencies) {\n        registerDependency({\n          type: \"dependency\",\n          file\n        });\n      }\n      return context;\n    };\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","setupTrackingContext","_fs","_interopRequireDefault","require","_quickLru","_hashConfig","_getModuleDependencies","_resolveConfig","_resolveConfigPath","_setupContextUtils","_parseDependency","_validateConfigJs","_contentJs","obj","__esModule","default","configPathCache","maxSize","candidateFilesCache","WeakMap","getCandidateFiles","context","tailwindConfig","has","candidateFiles","parseCandidateFiles","set","getTailwindConfig","configOrPath","userConfigPath","prevConfig","prevConfigHash","prevDeps","prevModified","newDeps","map","dep","file","modified","newModified","Map","time","statSync","mtimeMs","file1","cache","newConfig","validateConfig","newHash","newConfig1","config","undefined","tailwindDirectives","registerDependency","root","result","tailwindConfigHash","configDependencies","contextDependencies","Set","size","add","opts","from","message","messages","type","getContext","fileModifiedMap","getFileModifiedMap","contentPath","dependency","changedContent","resolvedChangedContent","push"],"sources":["/home/sahithya/bios/login/fronte/node_modules/tailwindcss/lib/lib/setupTrackingContext.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, // DISABLE_TOUCH = TRUE\n// Retrieve an existing context from cache if possible (since contexts are unique per\n// source path), or set up a new one (including setting up watchers and registering\n// plugins) then return it\n\"default\", {\n    enumerable: true,\n    get: ()=>setupTrackingContext\n});\nconst _fs = /*#__PURE__*/ _interopRequireDefault(require(\"fs\"));\nconst _quickLru = /*#__PURE__*/ _interopRequireDefault(require(\"quick-lru\"));\nconst _hashConfig = /*#__PURE__*/ _interopRequireDefault(require(\"../util/hashConfig\"));\nconst _getModuleDependencies = /*#__PURE__*/ _interopRequireDefault(require(\"../lib/getModuleDependencies\"));\nconst _resolveConfig = /*#__PURE__*/ _interopRequireDefault(require(\"../public/resolve-config\"));\nconst _resolveConfigPath = /*#__PURE__*/ _interopRequireDefault(require(\"../util/resolveConfigPath\"));\nconst _setupContextUtils = require(\"./setupContextUtils\");\nconst _parseDependency = /*#__PURE__*/ _interopRequireDefault(require(\"../util/parseDependency\"));\nconst _validateConfigJs = require(\"../util/validateConfig.js\");\nconst _contentJs = require(\"./content.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nlet configPathCache = new _quickLru.default({\n    maxSize: 100\n});\nlet candidateFilesCache = new WeakMap();\nfunction getCandidateFiles(context, tailwindConfig) {\n    if (candidateFilesCache.has(context)) {\n        return candidateFilesCache.get(context);\n    }\n    let candidateFiles = (0, _contentJs.parseCandidateFiles)(context, tailwindConfig);\n    return candidateFilesCache.set(context, candidateFiles).get(context);\n}\n// Get the config object based on a path\nfunction getTailwindConfig(configOrPath) {\n    let userConfigPath = (0, _resolveConfigPath.default)(configOrPath);\n    if (userConfigPath !== null) {\n        let [prevConfig, prevConfigHash, prevDeps, prevModified] = configPathCache.get(userConfigPath) || [];\n        let newDeps = (0, _getModuleDependencies.default)(userConfigPath).map((dep)=>dep.file);\n        let modified = false;\n        let newModified = new Map();\n        for (let file of newDeps){\n            let time = _fs.default.statSync(file).mtimeMs;\n            newModified.set(file, time);\n            if (!prevModified || !prevModified.has(file) || time > prevModified.get(file)) {\n                modified = true;\n            }\n        }\n        // It hasn't changed (based on timestamps)\n        if (!modified) {\n            return [\n                prevConfig,\n                userConfigPath,\n                prevConfigHash,\n                prevDeps\n            ];\n        }\n        // It has changed (based on timestamps), or first run\n        for (let file1 of newDeps){\n            delete require.cache[file1];\n        }\n        let newConfig = (0, _resolveConfig.default)(require(userConfigPath));\n        newConfig = (0, _validateConfigJs.validateConfig)(newConfig);\n        let newHash = (0, _hashConfig.default)(newConfig);\n        configPathCache.set(userConfigPath, [\n            newConfig,\n            newHash,\n            newDeps,\n            newModified\n        ]);\n        return [\n            newConfig,\n            userConfigPath,\n            newHash,\n            newDeps\n        ];\n    }\n    // It's a plain object, not a path\n    let newConfig1 = (0, _resolveConfig.default)(configOrPath.config === undefined ? configOrPath : configOrPath.config);\n    newConfig1 = (0, _validateConfigJs.validateConfig)(newConfig1);\n    return [\n        newConfig1,\n        null,\n        (0, _hashConfig.default)(newConfig1),\n        []\n    ];\n}\nfunction setupTrackingContext(configOrPath) {\n    return ({ tailwindDirectives , registerDependency  })=>{\n        return (root, result)=>{\n            let [tailwindConfig, userConfigPath, tailwindConfigHash, configDependencies] = getTailwindConfig(configOrPath);\n            let contextDependencies = new Set(configDependencies);\n            // If there are no @tailwind or @apply rules, we don't consider this CSS\n            // file or its dependencies to be dependencies of the context. Can reuse\n            // the context even if they change. We may want to think about `@layer`\n            // being part of this trigger too, but it's tough because it's impossible\n            // for a layer in one file to end up in the actual @tailwind rule in\n            // another file since independent sources are effectively isolated.\n            if (tailwindDirectives.size > 0) {\n                // Add current css file as a context dependencies.\n                contextDependencies.add(result.opts.from);\n                // Add all css @import dependencies as context dependencies.\n                for (let message of result.messages){\n                    if (message.type === \"dependency\") {\n                        contextDependencies.add(message.file);\n                    }\n                }\n            }\n            let [context] = (0, _setupContextUtils.getContext)(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies);\n            let candidateFiles = getCandidateFiles(context, tailwindConfig);\n            // If there are no @tailwind or @apply rules, we don't consider this CSS file or it's\n            // dependencies to be dependencies of the context. Can reuse the context even if they change.\n            // We may want to think about `@layer` being part of this trigger too, but it's tough\n            // because it's impossible for a layer in one file to end up in the actual @tailwind rule\n            // in another file since independent sources are effectively isolated.\n            if (tailwindDirectives.size > 0) {\n                let fileModifiedMap = (0, _setupContextUtils.getFileModifiedMap)(context);\n                // Add template paths as postcss dependencies.\n                for (let contentPath of candidateFiles){\n                    for (let dependency of (0, _parseDependency.default)(contentPath)){\n                        registerDependency(dependency);\n                    }\n                }\n                for (let changedContent of (0, _contentJs.resolvedChangedContent)(context, candidateFiles, fileModifiedMap)){\n                    context.changedContent.push(changedContent);\n                }\n            }\n            for (let file of configDependencies){\n                registerDependency({\n                    type: \"dependency\",\n                    file\n                });\n            }\n            return context;\n        };\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}